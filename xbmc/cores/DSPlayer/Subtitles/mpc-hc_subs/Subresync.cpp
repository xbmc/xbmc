#include "stdafx.h"
#include "..\subpic\ISubPic.h"
#include "..\subtitles\VobSubFile.h"
#include "..\subtitles\RTS.h"

#include "Subresync.h"

CSubresync::CSubresync(void)
{
}

CSubresync::~CSubresync(void)
{
}

void CSubresync::AddShift(REFERENCE_TIME time, int val)
{
	m_delayTime.push_back(time);
	m_delayVal.push_back(val);
}

void CSubresync::RemoveAll()
{
	m_delayTime.clear();
	m_delayVal.clear();
}

void CSubresync::SetSubtitle(ISubStream* pSubStream, double fps)
{
	m_mode = NONE;
	m_sts.Empty();

	if(!pSubStream) return;

	CLSID clsid;
	pSubStream->GetClassID(&clsid);

	if(clsid == __uuidof(CVobSubFile))
	{
		CVobSubFile* pVSF = (CVobSubFile*)(ISubStream*)pSubStream;

		m_mode = VOBSUB;

		std::vector<CVobSubFile::SubPos>& sp = pVSF->m_langs[pVSF->m_iLang].subpos;

		for(int i = 0, j = sp.size(); i < j; i++)
		{
			CStdString str;
			str.Format(_T("%d,%d,%d,%d"), sp[i].vobid, sp[i].cellid, sp[i].fForced, i);
			m_sts.Add(TToW(str), false, (int)sp[i].start, (int)sp[i].stop);
		}

		m_sts.CreateDefaultStyle(DEFAULT_CHARSET);

		pVSF->m_fOnlyShowForcedSubs = false;
	}
	else if(clsid == __uuidof(CRenderedTextSubtitle))
	{
		CRenderedTextSubtitle* pRTS = (CRenderedTextSubtitle*)(ISubStream*)pSubStream;

		m_mode = TEXTSUB;

		//m_sts.Copy(*pRTS);
    m_sts.swap(*pRTS);
		m_sts.ConvertToTimeBased(fps);
		m_sts.Sort(true); /*!!m_fUnlink*/
	}

}


int CSubresync::FindNearestSub(__int64 rtPos)
{
	if (m_sts.size() == 0) return -1;

	long	lCurTime = (long) (rtPos / 10000) -1;

	if (lCurTime < m_sts[0].start) 
	{
		return 0;
	}

	for(int i = 1, j = m_sts.size(); i < j; i++)
	{
		if ((lCurTime >= m_sts[i-1].start) && (lCurTime < m_sts[i].start))
		{
			return i-1;
		}
	}

	return m_sts.size() - 1;
}


void CSubresync::ShiftSubtitle(int nItem, long lValue)
{
	while (nItem > 0 && (m_sts[nItem-1].end > m_sts[nItem].start + lValue))
		--nItem;

	for (size_t i = nItem; i<m_sts.size(); i++)
	{
		m_sts[i].start += lValue;
		m_sts[i].end   += lValue;
	}
}

bool CSubresync::SaveToDisk(ISubStream* pSubStream, double fps, const CStdString & movieName)
{
	if (m_delayTime.empty())
		return false;
	SetSubtitle(pSubStream, fps);
	for (size_t i=0; i<m_delayTime.size(); i++)
	{
		int nItem = FindNearestSub(m_delayTime[i]);
		if (nItem >= 0)	ShiftSubtitle(nItem, m_delayVal[i]);
	}

	m_sts.CreateSegments();

	m_sts.m_fUsingAutoGeneratedDefaultStyle = true; //prevent .style file
	if (m_sts.m_path.IsEmpty())
	{//for embedded subtitles
		int k = movieName.ReverseFind('.');
		m_sts.m_path = (k < 0 ? movieName : movieName.Left(k));
		if (!m_sts.m_name.IsEmpty())
			m_sts.m_path += L"." + m_sts.m_name;
		m_sts.m_exttype = (m_mode == VOBSUB ? EXTIDX : EXTSRT);
	}
	return m_sts.SaveAs(m_sts.m_path, m_sts.m_exttype);
}

