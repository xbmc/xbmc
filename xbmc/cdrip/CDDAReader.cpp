#include "stdafx.h"
#include "CDDAReader.h"
#include "..\utils\log.h"

CCDDAReader::CCDDAReader()
{
	m_sRipBuffer[0].pbtStream = NULL;
	m_sRipBuffer[1].pbtStream = NULL;

	m_iCurrentBuffer = 0;

	m_hReadEvent = CreateEvent(NULL, false, false, "rip read event");
	m_hDataReadyEvent = CreateEvent(NULL, false, false, "rip dataready event");
	m_hStopEvent = CreateEvent(NULL, false, false, "rip stop event");
}

CCDDAReader::~CCDDAReader()
{
	m_bStop = true;
	PulseEvent(m_hStopEvent);
	StopThread();

	CloseHandle(m_hReadEvent);
	CloseHandle(m_hDataReadyEvent);
	CloseHandle(m_hStopEvent);

	if (m_sRipBuffer[0].pbtStream == NULL) delete []m_sRipBuffer[0].pbtStream;
	if (m_sRipBuffer[0].pbtStream == NULL) delete []m_sRipBuffer[0].pbtStream;
}

bool CCDDAReader::Init(int iTrack)
{
	DWORD dwStartSector;
	DWORD dwEndSector;

	if (CDEX_OK != CR_Init(""))
	{
		CLog::Log(LOGERROR, "Error: CR_Init failed");
		return false;
	}

	// get and set cdrom params
	CR_GetCDROMParameters(&m_cdParams);

	//read around 128k per chunk instead of 0x1a which is the default. This makes the cd reading less noisy.
	m_cdParams.nNumReadSectors = 0x37; 
	CR_SetCDROMParameters(&m_cdParams);

	CR_ReadToc();
	dwStartSector = CR_GetTocEntry(iTrack - 1).dwStartSector;
	dwEndSector = CR_GetTocEntry(iTrack).dwStartSector-1;
	CLog::Log(LOGINFO, "Track %d, Sectors %d", CR_GetTocEntry(iTrack - 1).btTrackNumber,	dwEndSector - dwStartSector);

	// Open ripper
	if (CR_OpenRipper(&m_lBufferSize,	dwStartSector, dwEndSector) != CDEX_OK)
	{
		CLog::Log(LOGERROR, "Error: Failed to open ripper");
		return false;
	}

	// allocate 2 buffers
	m_sRipBuffer[0].pbtStream = new BYTE[m_lBufferSize];
	m_sRipBuffer[1].pbtStream = new BYTE[m_lBufferSize];

	Create();

	return true;
}

bool CCDDAReader::DeInit()
{
	m_bStop = true;
	SetEvent(m_hStopEvent);
	StopThread();

	m_iCurrentBuffer = 0;

	// free buffers
	if (m_sRipBuffer[0].pbtStream) delete []m_sRipBuffer[0].pbtStream;
	m_sRipBuffer[0].pbtStream = NULL;
	if (m_sRipBuffer[1].pbtStream) delete []m_sRipBuffer[1].pbtStream;
	m_sRipBuffer[1].pbtStream = NULL;

	// Close the Ripper session
	CR_CloseRipper();

	if (CDEX_OK != CR_DeInit())
	{
		CLog::Log(LOGERROR, "Error: CR_DeInit failed");
		return false;
	}

	return true;
}

int CCDDAReader::GetPercent()
{
	return m_iPercent;
}

int CCDDAReader::ReadChunk()
{
	CDEX_ERR ripErr;
	BOOL bAbort = false;

	ripErr = CR_RipChunk(m_sRipBuffer[m_iCurrentBuffer].pbtStream,
			&m_sRipBuffer[m_iCurrentBuffer].lBytesRead, bAbort);

	// Get progress indication
	m_iPercent = CR_GetPercentCompleted();

	if (CDEX_RIPPING_DONE == ripErr) return CDDARIP_DONE; 

	// Check for jitter errors
	if (CDEX_JITTER_ERROR == ripErr)
	{
		CLog::Log(LOGERROR, "Found Jitter Error while reading cdda data");
		/*
		DWORD dwStartSector, dwEndSector;
		// Get info where jitter error did occur
		CR_GetLastJitterErrorPosition(dwStartSector,dwEndSector);
		// and do something usefull with it ? :)*/
	}

	if (CDEX_ERROR == ripErr)	return CDDARIP_ERR;

	/*// Get relative jitter position
	nJitterPos = CR_GetJitterPosition();
	// Get the Peak Value
	nPeakValue = CR_GetPeakValue();
	// Get the number of jitter errors
	nJitterErrors = CR_GetNumberOfJitterErrors();
	*/
	return CDDARIP_OK;
}

void CCDDAReader::Process()
{
	// fill first buffer
	m_iCurrentBuffer = 0;
	HANDLE hHandles[2] = { m_hReadEvent, m_hStopEvent };

	m_sRipBuffer[0].iRipError = ReadChunk();
	SetEvent(m_hDataReadyEvent);
	
	while (!m_bStop)
	{
		// wait until someone called GetData()
		if (WaitForMultipleObjects(2, hHandles, false, INFINITE) == WAIT_OBJECT_0)
		{
			// event generated by m_hReadEvent, continue
			// switch buffer and start reading in this one
			m_iCurrentBuffer = m_iCurrentBuffer ? 0 : 1;
			m_sRipBuffer[m_iCurrentBuffer].iRipError = ReadChunk();

			SetEvent(m_hDataReadyEvent);
		}
	}
}

int CCDDAReader::GetData(BYTE** stream, long& lBytes)
{
	// wait until we are sure we have a buffer that is filled
	WaitForSingleObject(m_hDataReadyEvent, INFINITE);

	int iError = m_sRipBuffer[m_iCurrentBuffer].iRipError;
	*stream = m_sRipBuffer[m_iCurrentBuffer].pbtStream;
	lBytes = m_sRipBuffer[m_iCurrentBuffer].lBytesRead;

	// got data buffer, signal thread so it can start filling the other buffer
	SetEvent(m_hReadEvent);
	return iError;
}
