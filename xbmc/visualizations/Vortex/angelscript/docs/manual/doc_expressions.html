<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AngelScript: Expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="doc_expressions">Expressions </a></h1><ul>
<li><a class="el" href="doc_expressions.html#assignment">Assignments</a></li><li><a class="el" href="doc_expressions.html#compound">Compound assignments</a></li><li><a class="el" href="doc_expressions.html#function">Function call</a></li><li><a class="el" href="doc_expressions.html#conversion">Type conversions</a></li><li><a class="el" href="doc_expressions.html#math">Math operators</a></li><li><a class="el" href="doc_expressions.html#bits">Bitwise operators</a></li><li><a class="el" href="doc_expressions.html#logic">Logic operators</a></li><li><a class="el" href="doc_expressions.html#equal">Equality comparison operators</a></li><li><a class="el" href="doc_expressions.html#relation">Relational comparison operators</a></li><li><a class="el" href="doc_expressions.html#identity">Identity comparison operators</a></li><li><a class="el" href="doc_expressions.html#increment">Increment operators</a></li><li><a class="el" href="doc_expressions.html#index">Indexing operator</a></li><li><a class="el" href="doc_expressions.html#condition">Conditional expression</a></li><li><a class="el" href="doc_expressions.html#member">Member access</a></li><li><a class="el" href="doc_expressions.html#handle">Handle-of</a></li><li><a class="el" href="doc_expressions.html#parenthesis">Parenthesis</a></li><li><a class="el" href="doc_expressions.html#scope">Scope resolution</a></li></ul>
<h2><a class="anchor" name="assignment">
Assignments</a></h2>
<pre>  lvalue = rvalue;</pre><p>
<code>lvalue</code> must be an expression that evaluates to a memory location where the expression value can be stored, e.g. a variable. An assignment evaluates to the same value and type of the data stored. The right hand expression is always computed before the left.<h2><a class="anchor" name="compound">
Compound assignments</a></h2>
<pre>
  lvalue += rvalue;
  lvalue = lvalue + rvalue;
</pre><p>
A compound assignment is a combination of an operator followed by the assignment. The two expressions above means practically the same thing. Except that first one is more efficient in that the lvalue is only evaluated once, which can make a difference if the lvalue is complex expression in itself.<p>
Available operators: <code>+= -= *= /= = &amp;= |= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code><h2><a class="anchor" name="function">
Function call</a></h2>
<pre>
  func();
  func(arg);
  func(arg1, arg2);
  lvalue = func();
</pre><p>
Functions are called to perform an action, and possibly return a value that can be used in further operations. If a function takes more than one argument, the argument expressions are evaluated in the reverse order, i.e. the last argument is evaluated first.<h2><a class="anchor" name="conversion">
Type conversions</a></h2>
<pre>
  // implicitly convert the clss handle to a intf handle
  intf @a = @clss();</pre><p>
<pre>  // explicitly convert the intf handle to a clss handle
  clss @b = cast&lt;clss&gt;(a);
</pre><p>
Object handles can be converted to other object handles with the cast operator. If the cast is valid, i.e. the true object implements the class or interface being requested, the operator returns a valid handle. If the cast is not valid, the cast returns a null handle.<p>
The above is called a reference cast, and only works for types that support object handles. In this case the handle still refers to the same object, it is just exposed through a different interface.<p>
Types that do not support object handles can be converted with a value cast instead. In this case a new value is constructed, or in case of objects a new instance of the object is created.<p>
<pre>
  // implicit value cast
  int a = 1.0f;</pre><p>
<pre>  // explicit value cast
  float b = float(a)/2;
</pre><p>
In most cases an explicit cast is not necessary for primitive types, however, as the compiler is usually able to do an implicit cast to the correct type.<h2><a class="anchor" name="math">
Math operators</a></h2>
<pre>
  c = -(a + b);
</pre><p>
<table cellspacing="0" cellpadding="0" border="0">
<tr>
<td width="70" valign="top"><b>operator</b></td><td width="100" valign="top"><b>description</b></td><td width="80" valign="top"><b>left hand</b></td><td width="80" valign="top"><b>right hand</b></td><td width="80" valign="top"><b>result</b> </td></tr>
<tr>
<td width="70" valign="top"><code>+</code> </td><td width="100" valign="top">unary positive </td><td width="80" valign="top">&nbsp; </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>-</code> </td><td width="100" valign="top">unary negative </td><td width="80" valign="top">&nbsp; </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>+</code> </td><td width="100" valign="top">addition </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>-</code> </td><td width="100" valign="top">subtraction </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>*</code> </td><td width="100" valign="top">multiplication </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>/</code> </td><td width="100" valign="top">division </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>%</code> </td><td width="100" valign="top">modulos </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td><td width="80" valign="top"><em>NUM</em> </td></tr>
</table>
<p>
Plus and minus can be used as unary operators as well. NUM can be exchanged for any numeric type, e.g. <code>int</code> or <code>float</code>. Both terms of the dual operations will be implicitly converted to have the same type. The result is always the same type as the original terms. One exception is unary negative which is not available for <code>uint</code>.<h2><a class="anchor" name="bits">
Bitwise operators</a></h2>
<pre>
  c = ~(a | b);
</pre><p>
<table cellspacing="0" cellpadding="0" border="0">
<tr>
<td width="70" valign="top"><b>operator</b> </td><td width="130" valign="top"><b>description</b> </td><td width="80" valign="top"><b>left hand</b> </td><td width="80" valign="top"><b>right hand</b> </td><td width="80" valign="top"><b>result</b> </td></tr>
<tr>
<td width="70" valign="top"><code>~</code> </td><td width="130" valign="top">bitwise complement </td><td width="80" valign="top">&nbsp; </td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>&amp;</code> </td><td width="130" valign="top">bitwise and </td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>|</code> </td><td width="130" valign="top">bitwise or </td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>^</code> </td><td width="130" valign="top">bitwise xor </td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>&lt;&lt;</code> </td><td width="130" valign="top">left shift </td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>&gt;&gt;</code> </td><td width="130" valign="top">right shift </td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em> </td></tr>
<tr>
<td width="70" valign="top"><code>&gt;&gt;&gt;</code></td><td width="130" valign="top">arithmetic right shift</td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em></td><td width="80" valign="top"><em>NUM</em> </td></tr>
</table>
<p>
All except <code>~</code> are dual operators.<h2><a class="anchor" name="logic">
Logic operators</a></h2>
<pre>
  if( a and b or not c )
  {
    // ... do something
  }
</pre><p>
<table cellspacing="0" cellpadding="0" border="0">
<tr>
<td width="70" valign="top"><b>operator</b> </td><td width="130" valign="top"><b>description</b> </td><td width="80" valign="top"><b>left hand</b> </td><td width="80" valign="top"><b>right hand</b> </td><td width="80" valign="top"><b>result</b> </td></tr>
<tr>
<td width="70" valign="top"><code>not</code></td><td width="130" valign="top">logical not </td><td width="80" valign="top">&nbsp; </td><td width="80" valign="top"><code>bool</code></td><td width="80" valign="top"><code>bool</code> </td></tr>
<tr>
<td width="70" valign="top"><code>and</code></td><td width="130" valign="top">logical and </td><td width="80" valign="top"><code>bool</code></td><td width="80" valign="top"><code>bool</code></td><td width="80" valign="top"><code>bool</code> </td></tr>
<tr>
<td width="70" valign="top"><code>or</code> </td><td width="130" valign="top">logical or </td><td width="80" valign="top"><code>bool</code></td><td width="80" valign="top"><code>bool</code></td><td width="80" valign="top"><code>bool</code> </td></tr>
<tr>
<td width="70" valign="top"><code>xor</code></td><td width="130" valign="top">logical exclusive or</td><td width="80" valign="top"><code>bool</code></td><td width="80" valign="top"><code>bool</code></td><td width="80" valign="top"><code>bool</code> </td></tr>
</table>
<p>
Boolean operators only evaluate necessary terms. For example in expression <code>a and b</code>, <code>b</code> is only evaluated if <code>a</code> is <code>true</code>.<p>
Each of the logic operators can be written as symbols as well, i.e. <code>||</code> for <code>or</code>, <code>&amp;&amp;</code> for <code>and</code>, <code>^^</code> for <code>xor</code>, and <code>!</code> for <code>not</code>.<h2><a class="anchor" name="equal">
Equality comparison operators</a></h2>
<pre>
  if( a == b )
  {
    // ... do something
  }
</pre><p>
The operators <code>==</code> and <code>!=</code> are used to compare two values to determine if they are equal or not equal, respectively. The result of this operation is always a boolean value.<h2><a class="anchor" name="relation">
Relational comparison operators</a></h2>
<pre>
  if( a &gt; b )
  {
    // ... do something
  }
</pre><p>
The operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> are used to compare two values to determine their relationship. The result is always a boolean value.<h2><a class="anchor" name="identity">
Identity comparison operators</a></h2>
<pre>
  if( a is null )
  {
    // ... do something
  }
  else if( a is b )
  {
    // ... do something
  }
</pre><p>
The operators <code>is</code> and <code>!is</code> are used to compare the identity of two objects, i.e. to determine if the two are the same object or not. These operators are only valid for reference types as they compare the address of two objects. The result is always a boolean value.<h2><a class="anchor" name="increment">
Increment operators</a></h2>
<pre>
  // The following means a = i; i = i + 1;
  a = i++;</pre><p>
<pre>  // The following means i = i - 1; b = i;
  b = --i;
</pre><p>
These operators can be placed either before or after an lvalue to increment/decrement its value either before or after the value is used in the expression. The value is always incremented or decremented with 1.<h2><a class="anchor" name="index">
Indexing operator</a></h2>
<pre>
  arr[i] = 1;
</pre><p>
This operator is used to access an element contained within the object. Depending on the object type, the expression between the <code>[]</code> needs to be of different types.<h2><a class="anchor" name="condition">
Conditional expression</a></h2>
<pre>
  choose ? a : b;
</pre><p>
If the value of <code>choose</code> is <code>true</code> then the expression returns <code>a</code> otherwise it will return <code>b</code>. Both <code>a</code> and <code>b</code> must be of the same type.<h2><a class="anchor" name="member">
Member access</a></h2>
<pre>
  object.property = 1;
  object.method();
</pre><p>
<code>object</code> must be an expression resulting in a data type that have members. <code>property</code> is the name of a member variable that can be read/set directly. <code>method</code> is the name of a member method that can be called on the object.<h2><a class="anchor" name="handle">
Handle-of</a></h2>
<pre>
  // Make handle reference the object instance
  @handle = @object;</pre><p>
<pre>  // Clear the handle and release the object it references
  @handle = null;
</pre><p>
Object handles are references to an object. More than one handle can reference the same object, and only when no more handles reference an object is the object destroyed.<p>
The members of the object that the handle references are accessed the same way through the handle as if accessed directly through the object variable, i.e. with <code>.</code> operator.<h2><a class="anchor" name="parenthesis">
Parenthesis</a></h2>
<pre>
  a = c * (a + b);
  if( (a or b) and c )
  {
    // ... do something
  }
</pre><p>
Parenthesis are used to group expressions when the <a class="el" href="doc_operator_precedence.html">operator precedence</a> does not give the desired order of evaluation.<h2><a class="anchor" name="scope">
Scope resolution</a></h2>
<pre>
  int value;
  void function()
  {
    int value;        // local variable overloads the global variable
    ::value = value; // use scope resolution operator to refer to the global variable 
  } 
</pre><p>
The scope resolution operator <code>::</code> can be used to access variables or functions from another scope when the name is overloaded by a local variable or function. Write the scope name on the left (or blank for the global scope) and the name of the variable/function on the right. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Dec 16 19:34:51 2009 for AngelScript by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
