<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AngelScript: Registering a function</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="doc_register_func">Registering a function </a></h1>This article aims to explain the way functions are registered with AngelScript, and some of the differences between C++ and AngelScript that the developer needs to be aware of in order to be successful in registering the application interface that the scripts will use. The principles learned here are used in several locations, such as <a class="el" href="classas_i_script_engine.html#754fafd069d8e0c19baff2dc222893b0">RegisterGlobalFunction</a>, <a class="el" href="classas_i_script_engine.html#6686c12ef37f4a4b1f9e90997b4756d0">RegisterObjectMethod</a>, <a class="el" href="classas_i_script_engine.html#7ea3c93dea338b0287027de0e4895dcb">RegisterObjectBehaviour</a>, etc.<h2><a class="anchor" name="doc_register_func_1">
How to get the address of the application function or method</a></h2>
The macros <a class="el" href="angelscript_8h.html#78f8f2c7f1c88b12e74a5ac47b4184ae">asFUNCTION</a>, <a class="el" href="angelscript_8h.html#153aee5a6228913a469b6e6867e54efb">asFUNCTIONPR</a>, <a class="el" href="angelscript_8h.html#7345e6b3afabec24efd0ff77886d49a6">asMETHOD</a>, and <a class="el" href="angelscript_8h.html#c45ccb5854326cce38d721e2c00f1563">asMETHODPR</a> have been implemented to facilitate the task of getting the function pointer and passing them on to the script engine.<p>
The asFUNCTION takes the function name as the parameter, which works for all global functions that do not have any overloads. If you use overloads, i.e. multiple functions with the same name but with different parameters, then you need to use asFUNCTIONPR instead. This macro takes as parameter the function name, parameter list, and return type, so that the C++ compiler can resolve exactly which overloaded function to take the address of.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Global function</span>
<span class="keywordtype">void</span> globalFunc();
r = engine-&gt;<a class="code" href="classas_i_script_engine.html#754fafd069d8e0c19baff2dc222893b0" title="Registers a global function.">RegisterGlobalFunction</a>(<span class="stringliteral">"void globalFunc()"</span>, <a class="code" href="angelscript_8h.html#78f8f2c7f1c88b12e74a5ac47b4184ae" title="Returns an asSFuncPtr representing the function specified by the name.">asFUNCTION</a>(globalFunc), <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e468ae43cc91cdfc3fa4590c9e6164e4f4" title="A cdecl function.">asCALL_CDECL</a>); assert( r &gt;= 0 );

<span class="comment">// Overloaded global functions</span>
<span class="keywordtype">void</span> globalFunc2(<span class="keywordtype">int</span>);
<span class="keywordtype">void</span> globalFunc2(<span class="keywordtype">float</span>);
r = engine-&gt;<a class="code" href="classas_i_script_engine.html#754fafd069d8e0c19baff2dc222893b0" title="Registers a global function.">RegisterGlobalFunction</a>(<span class="stringliteral">"void globalFunc2(int)"</span>, <a class="code" href="angelscript_8h.html#153aee5a6228913a469b6e6867e54efb" title="Returns an asSFuncPtr representing the function specified by the name, parameter...">asFUNCTIONPR</a>(globalFunc2, (<span class="keywordtype">int</span>), <span class="keywordtype">void</span>), <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e468ae43cc91cdfc3fa4590c9e6164e4f4" title="A cdecl function.">asCALL_CDECL</a>); assert( r &gt;= 0 );
</pre></div><p>
The same goes for asMETHOD and asMETHODPR. The difference between these and asFUNCTION/asFUNCTIONPR is that the former take the class name as well as parameter.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Object
{
  <span class="comment">// Class method</span>
  <span class="keywordtype">void</span> method();
  
  <span class="comment">// Overloaded method</span>
  <span class="keywordtype">void</span> method2(<span class="keywordtype">int</span> input);
  <span class="keywordtype">void</span> method2(<span class="keywordtype">int</span> input, <span class="keywordtype">int</span> &amp;output);
};

<span class="comment">// Registering the class method</span>
r = engine-&gt;<a class="code" href="classas_i_script_engine.html#6686c12ef37f4a4b1f9e90997b4756d0" title="Registers a method for the object type.">RegisterObjectMethod</a>(<span class="stringliteral">"object"</span>, <span class="stringliteral">"void method()"</span>, <a class="code" href="angelscript_8h.html#7345e6b3afabec24efd0ff77886d49a6" title="Returns an asSFuncPtr representing the class method specified by class and method...">asMETHOD</a>(Object,method), <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4ea516c8742acc1edff6a43dc1bb09e96" title="A thiscall class method.">asCALL_THISCALL</a>); assert( r &gt;= 0 );

<span class="comment">// Registering the overloaded methods</span>
r = engine-&gt;<a class="code" href="classas_i_script_engine.html#6686c12ef37f4a4b1f9e90997b4756d0" title="Registers a method for the object type.">RegisterObjectMethod</a>(<span class="stringliteral">"object"</span>, <span class="stringliteral">"void method2(int)"</span>, <a class="code" href="angelscript_8h.html#c45ccb5854326cce38d721e2c00f1563" title="Returns an asSFuncPtr representing the class method specified by class, method name...">asMETHODPR</a>(Object, method2, (<span class="keywordtype">int</span>), <span class="keywordtype">void</span>), <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4ea516c8742acc1edff6a43dc1bb09e96" title="A thiscall class method.">asCALL_THISCALL</a>); assert( r &gt;= 0 );
r = engine-&gt;<a class="code" href="classas_i_script_engine.html#6686c12ef37f4a4b1f9e90997b4756d0" title="Registers a method for the object type.">RegisterObjectMethod</a>(<span class="stringliteral">"object"</span>, <span class="stringliteral">"void method2(int, int &amp;out)"</span>, <a class="code" href="angelscript_8h.html#c45ccb5854326cce38d721e2c00f1563" title="Returns an asSFuncPtr representing the class method specified by class, method name...">asMETHODPR</a>(Object, method2, (<span class="keywordtype">int</span>, <span class="keywordtype">int</span>&amp;), <span class="keywordtype">void</span>), <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4ea516c8742acc1edff6a43dc1bb09e96" title="A thiscall class method.">asCALL_THISCALL</a>); assert( r &gt;= 0 );
</pre></div><h2><a class="anchor" name="doc_register_func_2">
Calling convention</a></h2>
AngelScript accepts most common calling conventions that C++ uses, i.e. cdecl, stdcall, and thiscall. There is also a generic calling convention that can be used for example when native calling conventions are not supported on the target platform.<p>
All functions and behaviours must be registered with the <a class="el" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e468ae43cc91cdfc3fa4590c9e6164e4f4">asCALL_CDECL</a>, <a class="el" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4138a08e8363ebc695636dfe987674e2e">asCALL_STDCALL</a>, <a class="el" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4ea516c8742acc1edff6a43dc1bb09e96">asCALL_THISCALL</a>, or <a class="el" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4750c26b6a6e0c9ccbb93078f532ef8ce">asCALL_GENERIC</a> flags to tell AngelScript which calling convention the application function uses. The special conventions <a class="el" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4c08652c72f1cc0dc81c37812fab0e253">asCALL_CDECL_OBJLAST</a> and <a class="el" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e47c3e88628c2722d0a103b411d4aceaa0">asCALL_CDECL_OBJFIRST</a> can also be used wherever asCALL_THISCALL is accepted, in order to simulate a class method through a global function.<p>
If the incorrect calling convention is given on the registration you'll very likely see the application crash with a stack corruption whenever the script engine calls the function. cdecl is the default calling convention for all global functions in C++ programs, so if in doubt try with asCALL_CDECL first. The calling convention only differs from cdecl if the function is explicitly declared to use a different convention, or if you've set the compiler options to default to another convention.<p>
For class methods there is only the thiscall convention, except when the method is static, as those methods are in truth global functions in the class namespace. Normal methods, virtual methods, and methods for classes with multiple inheritance are all registered the same way, with asCALL_THISCALL. Classes with <a class="el" href="doc_register_func.html#doc_register_func_4">virtual inheritance are not supported natively</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_generic.html">The generic calling convention</a></dd></dl>
<h2><a class="anchor" name="doc_register_func_4">
Virtual inheritance is not supported</a></h2>
Registering class methods for classes with virtual inheritance is not supported due to the high complexity involved with them. Each compiler implements the method pointers for these classes differently, and keeping the code portable would be very difficult. This is not a great loss though, as classes with virtual inheritance are relatively rare, and it is easy to write simple proxy functions where the classes to exist.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>A { <span class="keywordtype">void</span> SomeMethodA(); };
<span class="keyword">class </span>B : <span class="keyword">virtual</span> A {};
<span class="keyword">class </span>C : <span class="keyword">virtual</span> A {};
<span class="keyword">class </span>D : <span class="keyword">public</span> B, <span class="keyword">public</span> C {};

<span class="comment">// Need a proxy function for registering SomeMethodA for class D</span>
<span class="keywordtype">void</span> D_SomeMethodA_proxy(D *d)
{
  <span class="comment">// The C++ compiler will resolve the virtual method for us</span>
  d-&gt;SomeMethodA();
}

<span class="comment">// Register the global function as if it was a class method, </span>
<span class="comment">// but with calling convention asCALL_CDECL_OBJLAST</span>
engine-&gt;<a class="code" href="classas_i_script_engine.html#6686c12ef37f4a4b1f9e90997b4756d0" title="Registers a method for the object type.">RegisterObjectMethod</a>(<span class="stringliteral">"D"</span>, <span class="stringliteral">"void SomeMethodA()"</span>, <a class="code" href="angelscript_8h.html#78f8f2c7f1c88b12e74a5ac47b4184ae" title="Returns an asSFuncPtr representing the function specified by the name.">asFUNCTION</a>(D_SomeMethodA_proxy), <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4c08652c72f1cc0dc81c37812fab0e253" title="A cdecl function that takes the object pointer as the last parameter.">asCALL_CDECL_OBJLAST</a>);
</pre></div><p>
If you have a lot of classes with virtual inheritance, you should probably think about writing a template proxy function, so you don't have to manually write all the proxy functions.<h2><a class="anchor" name="doc_register_func_3">
A little on type differences</a></h2>
AngelScript supports most of the same types that C++ has, but there are differences that you'll need to know when registering functions, methods, and behaviours.<p>
All primitive types in C++ have a corresponding type in AngelScript, though sometimes with a slightly different name, i.e. <code>char</code> in C++ is <code>int8</code> in AngelScript. You can see a list of all types and their match in respective language <a class="el" href="doc_as_vs_cpp_types.html">here</a>.<p>
Pointers do not exist in AngelScript in the same way as in C++, so you need to decide on how they should be passed. For this you have two options, either as reference, or as an <a class="el" href="doc_obj_handle.html">object handle</a>. Most common uses of pointers in parameters can be represented with either references or object handles in AngelScript, for the few uses where it cannot be done a wrapper function must be written to simplify the function interface to a form that AngelScript can understand.<p>
Parameter references in AngelScript have an additional restriction over the C++ references, and that is that you must specify the intended direction of the value that the reference points to, i.e. whether it is an input value, output value, or if the value is both input and output. This is done by adding the keywords <code>in</code>, <code>out</code>, or <code>inout</code> after the &amp; character. If no keyword is given AngelScript assumes <code>inout</code>. Value types can only use <code>in</code> and <code>out</code>, as AngelScript cannot guarantee the safety of the references otherwise.<p>
Object handles are reference counted pointers to objects, so when using these you need to pay attention to the reference counter, e.g. whenever you receive an object handle from AngelScript, you must make sure to decrease the reference when you're done with it. Similarly whenever you pass an object handle to AngelScript you must make sure that reference is accounted for, so that AngelScript doesn't destroy the object too early. If your application functions are not already prepared to work like this, you can most of the time tell AngelScript to handle the reference counting for you by using the auto-handles, <code>@+</code>.<p>
Strings are a bit complicated as C++ doesn't have one standard way of dealing with them. Because of that AngelScript also doesn't impose a specific string type on the applications. Instead the application needs to register the string type it wants to use, and then the string parameters needs to be registered accordingly. AngelScript comes with two standard add-ons for registering string types, one for std::string, and another for a light wrapper on std::string, which for the most part is compatible with std::string, except that it is reference counted.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_obj_handle.html">Object handles</a>, <a class="el" href="doc_as_vs_cpp_types.html">Datatypes in AngelScript and C++</a>, <a class="el" href="doc_addon_std_string.html">string object (STL)</a>, <a class="el" href="doc_addon_string.html">string object (reference counted)</a> </dd></dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Dec 16 19:34:51 2009 for AngelScript by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
