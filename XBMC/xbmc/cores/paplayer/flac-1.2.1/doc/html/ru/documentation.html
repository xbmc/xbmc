<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<!-- Copyright (c) 2000,2001,2002,2003,2004,2005,2006,2007  Josh Coalson -->
<!-- Permission is granted to copy, distribute and/or modify this document -->
<!-- under the terms of the GNU Free Documentation License, Version 1.1 -->
<!-- or any later version published by the Free Software Foundation; -->
<!-- with no invariant sections. -->
<!-- A copy of the license can be found at http://www.gnu.org/copyleft/fdl.html -->
<HTML>
<HEAD>
<META CHARSET="windows-1251">
<TITLE>FLAC: документация</TITLE>
</HEAD>

<BODY>
<CENTER><TABLE cellpadding=0 cellspacing=0 border=0>
<TR>
<TD align=center>|</TD>
<TD height=22 align=center nowrap>
&nbsp;<A HREF="index.html">начало</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="news.html">новости</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="download.html">файлы</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="features.html">характеристики</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="goals.html">цели</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="format.html">формат</A>&nbsp;</TD>
<TD align=center>|</TD></TR>

<TR>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="id.html">id</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="comparison.html">сравнение</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="developers.html">разработка</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;документация&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="links.html">ссылки</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="authors.html">авторы</A>&nbsp;</TD>
<TD align=center>|</TD></TR>
</TABLE></CENTER>

<P><CENTER><TABLE cellpadding=0 cellspacing=0 border=0>
<TR><TD align=center>|</TD>
<TD height=22 align=center nowrap>
&nbsp;<A HREF="../documentation.html">english</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;русский</A>&nbsp;</TD>
<TD align=center>|</TD></TR>
</TABLE></CENTER></P>


<CENTER><H2>FLAC: документация</H2></CENTER>

<H3>Документация</H3>

<P>Эта страница разбита на следующие разделы:</P>

<UL>
	<LI><A HREF="#format">формат</A> - описание формата FLAC для пользователя (более детальное описание для разработчика приведено на <A HREF="format.html">этой</A> странице).</LI>
	<LI><A HREF="#flac"><B><TT>flac</TT></B></A> - иcпользование кодека <B><TT>flac</TT></B>, работающего из командной строки.</LI>
	<LI><A HREF="#metaflac"><B><TT>metaflac</TT></B></A> - использование редактора метаданных <B><TT>metaflac</TT></B>, работающего из командной строки.</LI>
	<LI><A HREF="#plugins">плагины</A> - документация для различных плагинов.</LI>
	<LI><A HREF="../api/index.html">API</A> для <B><TT>libFLAC</TT></B> и <B><TT>libFLAC++</TT></B> - для разработчиков, желающих использовать поддержку FLAC в своих продуктах.</LI>
	<LI><A HREF="#bugs">ошибки</A> - известные ошибки.</LI>
	<LI><A HREF="#monkey">как добавить поддержку FLAC в Monkey's Audio GUI</A></LI>
</UL>

<P>Помните, что онлайновая версия этого документа (на английском языке) включается в последний релиз.</P>

<A NAME="format">
<H3>Формат</H3>

<P>Опции по умолчанию для <B><TT>flac</TT></B> настроены на получение оптимального соотношения скорость/уровень сжатия для большинства типов входных файлов. Здесь описывается как можно попытаться увеличить уровень или скорость сжатия или с наибольшим эффектом использовать систему метаданных.</P>

<P>Основными частями потока являются:</P>

<P><BLOCKQUOTE><UL>
   <LI>Строка из четырех байтов &quot;fLaC&quot;.</LI>

   <LI>Блок метаданных <A HREF="format.html#def_STREAMINFO">STREAMINFO</A>.</LI>

   <LI>Другие необязательные блоки метаданных.</LI>

   <LI>Один или более аудио фреймов.</LI>
</UL></BLOCKQUOTE></P>

<P>Первые четыре байта идетифицируют поток FLAC. Следующие за ними метаданные содержат информацию о потоке, затем идут сжатые аудиоданные.</P>

<A NAME="metadata">
<H4>Метаданные</H4>

<P>FLAC определяет несколько типов блоков метаданных (все они перечислены на странице <A HREF="format.html">формат</A>). Блоки метаданных могут быть любого размера, новые блоки могут быть легко добавлены. Декодер имеет возможность пропускать неизветные ему блоки метаданных. Обязателен только блок STREAMINFO. В нем содержится частота дискретизация, количество каналов и т.п., а также данные позволяющие декодеру настроить буфферы. Сюда также записывается подпись MD5 <I>несжатых</I> аудиоданных. Это полезно для проверки всего потока после его передачи.</P>

<P>Другие блоки предназначены для резервирования места, хранения таблиц точек поиска, тегов, список разметки аудиодисков а также данных для конкретных приложений. Опции для добавления блоков PADDING или точек поиска приведены ниже. FLAC не нуждается в точках поиска, однако они позволяют значительно увеличить скорость доступа, а также могут быть использования для расстановки меток в аудио редакторах.</P>

<P>Если Вам нужен собственный блок метаданных, Вы можете определить его и запросить идентификатор <A HREF="id.html">здесь</A>. Вы можете зарезервировать блок PADDING необходимого размера и записать на его место свои данные после кодирования. Полученнный поток будет отвечать формату FLAC, декодеры распознающие эти блоки смогут их использовать, остальные будут их пропускать.</P>


<H4>Аудиоданные</H4>

<P>За метаданным следуют сжатые аудиоданные. Метаданные и аудиоданные не чередуются. Как и большинство кодеков FLAC делит входной поток на блоки и кодирует их независимо друг от друга. Блок упаковыватся во фрейм и добавляется к потоку. Базовый кодер использует блоки постоянного размера для всего потока, однако формат предусматривает наличие блоков разной длины в потоке.</P>


<H4>Разбиение на блоки</H4>

<P>Размер блока - очень важный параметр для кодирования. Если он очень мал, то в потоке будет слишком заголовков фреймов, что уменьшит уровень сжатия. Если размер большой, то кодер не сможет подобрать эффективную модель сжатия. Понимание процесса моделирования поможет Вам увеличить уровень сжатия для некоторых типов входных данных. Обычно при использовании линейного прогнозирования на аудиоданных с частотой дискретизации 44.1 кГц оптимальный размер блока лежит в диапазоне 2-6 тысяч сэмплов. В этом случае значение по умолчанию - 4608. Если использовать быстрые постоянные предикторы, предпочтительнее меньшие размеры блоков, так как в этом случае размеры заголовков фреймов меньше.</P>


<H4>Межканальная декорреляция</H4>

<P>Если на вход поступают стерео аудиоданные, они могут пройти через стадию межканальной декорреляции. Правый и левый канал преобразуются к среднему и разностному по формулам: <TT>средний = (левый + правый)/2</TT>, <TT>разностный = левый - правый</TT>. В отличие от joint stereo этот процесс не приводит к потерям. Для данных с аудио компакт-дисков это обычно приводит к значительному увеличению уровня сжатия. Для включения использования этого метода кодирования <B><TT>flac</TT></B> имеет две опции: <TT>-m</TT> всегда делает разностную и независимую версию блока и выбирает наименьший фрейм и <TT>-M</TT>, которая адаптивно выбирает схему сжатия.</P>


<H4>Моделирование</H4>

<P>На следующем этапе кодер пытается аппроксимировать сигнал такой функцией, чтобы полученный после ее вычитания из оригинала результат (называемый разностью, остатком, ошибкой) можно было закодировать минимальным количеством битов. Параметры функций тоже должны записываться, поэтому они не должны занимать много места. FLAC использует два метода формирования аппроксимаций: 1) подгонка простого полинома к сигналу и 2) общее кодирование с линейными предикторами (LPC).</P>

<P>Во-первых, постоянное полиномиальное предсказание (<TT>-l 0</TT>) работает значительно быстрее, но менее точно, чем LPC. Чем выше порядок LPC, тем медленнее, но лучше будет модель. Однако с увеличением порядка выигрыш будет все менее значительным. В некоторой точке (обычно около 9) процедура кодера, определяющая наилучший порядок, начинает ошибаться и размер получаемых фреймов возрастает. Чтобы преодолеть это, можно использовать полный перебор (опция <TT>-e</TT>), что приведет к значительному увеличению времени кодирования.</P>

<P>Во-вторых, параметры для постоянных предикторов могут быть описаны тремя битами, а параметры для модели LPC зависят от количества бит на сэмпл и порядка LPC. Это значит, что размер заголовка фрейма зависит от выбранного метода и порядка и может повлиять на оптимальный размер блока.</P>


<H4>Остаточное кодирование</H4>

<P>Когда модель подобрана, кодер вычитает приближение из оригинала, чтобы получить остаточный (ошибочный) сигнал, который затем кодируется без потерь. Для этого используется то обстоятельство, что разностный сигнал обычно имеет распределение Лапласа и есть набор специальный кодов Хаффмана, называемые кодами Райса, позволяющие эффективно и быстро кодировать эти сигналы без использования словаря.</P>

<P>Кодирование Райса состоит из нахождения одного параметра, отвечающего распределению сигнала, а затем использования его для составления кодов. При изменении распределения меняется и оптимальный параметр, поэтому имеется метод позволяющий пересчитывать его по необходимости. Остаток может быть разбит на <I>контексты</I> или <I>разделы</I>, у каждого из которых будет свой параметр Райса. <B><TT>flac</TT></B> позволяет указать, как нужно производить разбиение, с помощью опции <TT>-r</TT>. Остаток может быть разбит на <I>2^n</I> раздела, если использовать <TT>-r n,n</TT>. Параметр <I>n</I> называется порядком раздела. Также кодер может искать в пределах от <I>m</I> до <I>n</I> порядка, выбирая лучший вариант, если указать <TT>-r m,n</TT>. Обычно выбор <I>n</I> не влияет на скорость кодирования. От разницы между <I>m</I> и <I>n</I> сильно зависит время работы, чем она больше, тем больше времени будет затрачиваться на поиск лучшего порядка. Выбор размера блока также влияет на оптимальный порядок раздела.</P>


<H4>Составление фреймов</H4>

<P>Аудиофрейму предшествует заголовок, который начинается с кода синхронизации и содержит минимум информации, необходимой декодеру для воспроизведения потока. Сюда также записывается номер блока или сэмпла и восьмибитная контрольная сумма самого заголовка. Код синхронизации, CRC заголовка фрейма и номер блока/сэмпла позволяют осуществлять пересинхронизацию и поиск даже в отсутствие точек поиска. В конце фрейма записывается его шестнадцатибитная контрольная сумма. Если базовый декодер обнаружит ошибку, будет сгенерирован блок тишины.</P>


<H4>Разное</H4>

<P>Чтобы поддерживать основные типы метаданных, базовый декодер умеет пропускать теги ID3V1 и ID3V2, поэтому их можно свободно добавлять. Теги ID3V2 должны располагаться перед маркером &quot;fLaC&quot;, а теги ID3V1 - в конце файла.</P>

<P>У <B><TT>flac</TT></B> есть опция (<TT>-V</TT>) для проверки выходных данных при кодировании. В этом случае декодер работает одновременно с кодером и его выход сравнивается с оригинальным вводом. Если будет найдено отличие, <B><TT>flac</TT></B> закончит работу с сообщением об ошибке.</P>


<A NAME="flac">
<H3><B><TT>flac</TT></B></H3>

<P><B><TT>flac</TT></B> - это кодек, работающий из командной строки. Входом для кодера и выходом для декодера должны быть данные в формате RIFF WAVE, AIFF или в виде потока сэмплов без заголовка. <B><TT>flac</TT></B> использует только линейные PCM сэмплы (другими словами, A-LAW, uLAW, и т.п. не поддерживаются). Следующим ограничением является то, что во кодируемом файле сэмплы должны быть 8, 16 или 24-битными. Это не ограничение формата, просто так работают базовый кодер и декодер.</P>

<P><B><TT>flac</TT></B> предполагает, что файлы RIFF WAVE имеют суффикс ".wav", а файлы формата AIFF имеют суффиксы ".aif", ".aiff" или встречен заголовок AIFF; это умолчание может быть переопределено специальным ключом. Также предполагается, что файлы с суффиком ".ogg" имеют формат Ogg-FLAC. В остальных случаях <B><TT>flac</TT></B> не делает предположений о суффиксах, хотя по соглашению файлы FLAC имеют суффикс ".flac" (или ".fla" на старых файловых системах таких как FAT-16).</P>

<P>Перед полным описанием ключей, используемых <B><TT>flac</TT></B>, обратим внимание на то что: 1) по умолчанию <B><TT>flac</TT></B> сжимает файлы (для декодирования используйте ключ <TT>-d</TT>); 2) ключи <TT>-0..-8</TT>, а также <TT>--fast</TT> и <TT>--best</TT>, управляющие уровнем сжатия, являются синонимами для различных групп настроек кодирования. Того же эффекта можно добиться, используя наборы соответствующих ключей; 3) модель обработки входных и выходных файлов у <B><TT>flac</TT></B> аналогична <B><TT>gzip</TT></B>.</P>

<P><B><TT>flac</TT></B> вызывается одним из четырех способов:</P>

<BLOCKQUOTE><UL>
    <LI>Кодирование:<BR><TT>flac [<I><A HREF="#general_options">&lt;основные_ключи&gt;</A></I>] [<I><A HREF="#format_options">&lt;настройки_формата&gt;</A></I>] [<I><A HREF="#encoding_options">&lt;опции_кодирования&gt;</A></I>] [входной_файл [...]]</TT></LI>

    <LI>Декодирование:<BR><TT>flac -d [<I><A HREF="#general_options">&lt;основные_ключи&gt;</A></I>] [<I><A HREF="#format_options">&lt;настройки_формата&gt;</A></I>] [<I><A HREF="#encoding_options">&lt;опции_кодирования&gt;</A></I>] [файл_FLAC [...]]</TT></LI>

    <LI>Тестирование:<BR><TT>flac -t [<I><A HREF="#general_options">&lt;основные_ключи&gt;</A></I>] [файл_FLAC [...]]</TT></LI>

    <LI>Анализ:<BR><TT>flac -a [<I><A HREF="#general_options">&lt;основные_ключи&gt;</A></I>] [<I><A HREF="#analysis_options">&lt;опции_анализа&gt;</A></I>] [файл_FLAC [...]]</TT></LI>
</UL></BLOCKQUOTE></P>

<P>В любом случае, если входной файл не указан, подразумевается стандартный ввод. Если указан только один входной файл, то это может быть "-" для стандартного ввода (stdin). Когда используется стандартный ввод, <B><TT>flac</TT></B> пишет в стандартный вывод (stdout).  В остальных случаях <B><TT>flac</TT></B> выполнит указанные действия для каждого входного файла и запишет результаты в файлы с аналогичными именами (при кодировании суффикс будет заменен на ".flac" или, если его не было, будет добавлен; при декодировании суффиксы также изменяются в соответствии с типом выходных данных.) Оригинал удаляется, только если указан ключ <TT>--delete-input-file</TT>.</P>

<P>Существуют особые формы вызова процедур кодирования/декодирования из стандандартного ввода в файл.</P>

<P><BLOCKQUOTE>
<UL>
    <LI><TT>flac [опции] - выходной_файл</TT></LI>

    <LI><TT>flac -d [опции] - выходной_файл</TT></LI>
</UL>

<P>которые лучше чем</P>

<UL>
    <LI><TT>flac [опции] &gt; выходной_файл</TT></LI>

    <LI><TT>flac -d [опции] &gt; выходной_файл</TT></LI>
</UL>
</BLOCKQUOTE></P>

<P>так как в первом случае сохраняется возможность произвести при необходимости последующую обработку файла, например для записи заголовков <TT>RIFF WAVE</TT> или <TT>STREAMINFO</TT>.</P>

<P>Данные в стандартный вывод можно перенаправить с помощью ключа <TT>-c</TT>.</P>

<P>Опции кодирования влияют на скорость работы и уровень сжатия. Настройки формата определяют расположение сэмплов, если на вход поступает файл без заголовка. Если у файла есть заголовок RIFF WAVE или AIFF, то настойки формата не нужны, так как они берутся из файла.</P>

<P>В режиме тестирования <B><TT>flac</TT></B> работает как и при декодировании, только выходной файл не записывается. Режимы декодирования и тестирования проверяют поток на наличие ошибок, а также сравнивают подпись MD5 декодированного потока с сохраненной подписью, даже если формат потока правильный.</P>

<H4><a name="general_options">Основные ключи</A></H4>
<TABLE border=1>
<TR><TD WIDTH=25%><TT>-v</TT>, <TT>--version</TT></TD>
<TD WIDTH=75%>Номер версии <B><TT>flac</TT></B>.</TD></TR>
	
<TR><TD><TT>-h</TT>, <TT>--help</TT></TD>
<TD>Вывести основные методы использования и список всех опций. При запуске <B><TT>flac</TT></B> без аргументов отображается краткая справка.</TD></TR>

<TR><TD><TT>-H</TT>, <TT>--explain</TT></TD>
<TD>Вывести справку полностью. При запуске <B><TT>flac</TT></B> без аргументов отображается краткая справка.</TD></TR>

<TR><TD><TT>-d</TT>, <TT>--decode</TT></TD>
<TD>Декодирование (по умолчанию <B><TT>flac</TT></B> кодирует). <B><TT>flac</TT></B> завершит работу с кодом выхода <TT>1</TT>, если будет встречена ошибка или контрольная сумма MD5 декодированного потока не совпадет с сохраненной. Если ошибок не будет, код возврата будет равен <TT>0</TT>.</TD></TR>

<TR><TD><TT>-t</TT>, <TT>--test</TT></TD>
<TD>Тестирование (то же самое, что и декодирование, только выход не записывается в файл). Коды возврата те же.</TD></TR>

<TR><TD><TT>-a</TT>, <TT>--analyze</TT></TD>
<TD>Анализ (то же самое, что и декодирование, только выходом является файл статистики). Коды возврата те же.  Режим предназначен в основном для разработчиков. В выходной текстовый файл записывается информация о каждом фрейме и подфрейме.</TD></TR>

<TR><TD><TT>-c</TT>, <TT>--stdout</TT></TD>
<TD>Направить результат в стандартный вывод (stdout).</TD></TR>

<TR><TD><TT>-s</TT>, <TT>--silent</TT></TD>
<TD>Не показывать статистику при кодировании/декодировании.</TD></TR>

<TR><TD><TT>-o файл</TT><BR><TT>--output-name=файл</TD>
<TD>Явно указать имя выходного файла, по умолчанию <B><TT>flac</TT></B> просто заменяет суффикс.</TD></TR>

<TR><TD><TT>--output-prefix=строка</TT></TD>
<TD>Добавляет префикс к каждому имени выходному файлу. Может имспользоваться для кодирования/декодирования файлов в другой каталог. Если указанная строка является частью пути, убедитесь, что она заканчивается слэшем '/'.</TD></TR>

<TR><TD><TT>--delete-input-file</TT></TD>
<TD>После успешного окончания кодирования/декодирования входной файл будет удален. Если произойдет ошибка, исходный файл останется.</TD></TR>

<TR><TD><TT>--skip={#|mm:ss.ss}</TT></TD>
<TD>Пропустить первые <TT>#</TT> сэмплов входного файла. Работает для кодирования и декодирования, но не для тестирования. Альтернативную форму mm:ss.ss можно использовать, чтобы указать минуты, секунды и сотые секунды.<BR>
Например:<BR>
<TT>--skip=123</TT> : пропустить первые 123 сэмпла входного файла<BR>
<TT>--skip=1:23.45</TT> : пропустить 1 минуту 23.45 секунд
</TD></TR>

<TR><TD><TT>--until={#|[+|-]mm:ss.ss}</TT></TD>
<TD>Остановиться на данном сэмпле входного файла. Работает для кодирования и декодирования, но не для тестирования. Сэмпл с указанным номером не включается в вывод. Альтернативную форму mm:ss.ss можно использовать, чтобы указать минуты, секунды и сотые секунды. Если впереди стоит знак <TT>+</TT>, то последний сэмпл берется от начальной точки воспроизведения, если - <TT>-</TT>, то последний сэмпл вычисляется от конца потока аудио.<BR>
Например:<BR>
<TT>--until=123</TT> : декодировать первые 123 сэмпла входного файла (сэмплы 0-122)<BR>
<TT>--until=1:23.45</TT> : декодировать 1 минуту 23.45 секунд<BR>
<TT>--skip=1:00 --until=+1:23.45</TT> : декодировать от 1:00.00 до 2:23.45<BR>
<TT>--until=-1:23.45</TT> : декодировать все, кроме последней 1 минуты и 23.45 секунд<BR>
<TT>--until=-0:00</TT> : декодировать весь ввод
</TD></TR>

<TR><TD><TT>--ogg</TT></TD>
<TD><P>При кодировании генерируется вывод в формате Ogg-FLAC вместо "родного" FLAC. Потоки Ogg-FLAC представляют собой потоки FLAC обернутые в транспортный уровень Ogg. Полученный файл будет иметь суффикс '.ogg' и будет декодироваться утилитой <TT><B>flac</B></TT>.</P>
<P>При декодировании формат ввода однозначно определяется как Ogg-FLAC. Это полезно при получении данных со стандартного ввода или если у файла суффикс не '.ogg'.</P></TD></TR>

<TR><TD><TT>--serial-number=#</TT></TD>
<TD>При использовании с ключом <TT>--ogg</TT> определяет серийный номер для потока FLAC. При кодировании без явно указанного серийного номера <B><TT>flac</TT></B> использует '0'. При декодировании по умолчанию используется серийный номер определенный на первой странице.</TD></TR>
</TABLE>


<H4><a name="analysis_options">Опции анализа</H4>
<TABLE border=1>
<TR><TD width=25%><TT>--residual-text</TT></TD>
<TD width=75%>Добавляет в файл остаточный сигнал. Результирующий файл получается <B>очень большим</B>.</TD></TR>

<TR><TD><TT>--residual-gnuplot</TT></TD>
<TD>Создает файлы-диаграммы для каждого подфрейма. В каждом файле будет остаточное распределение для подфрейма. Будет создано <B>очень много</B> файлов.</TD></TR>
</TABLE>


<H4><a name="decoding_options">Опции декодирования</H4>
<TABLE border=1>
<TR><TD width=30%><TT>-F</TT>,<BR><TT>--decode-through-errors</TT></TD>
<TD width=70%>По умолчанию <B><TT>flac</TT></B> прекращает декодирование в случае ошибки в потоке и удаляет частично декодированный файл. Использование ключа <TT>-F</TT> ведет к тому, что сообщения об ошибках выводятся, но <B><TT>flac</TT></B> продолжает работу до конца. Обратите внимание, что в результате такого декодирования в выходном файле могут быть пропущены сэмплы или появится блоки тишины.</TD></TR>
</TABLE>

<H4><a name="encoding_options">Опции кодирования</A></H4>
<TABLE border=1>
<TR><TD width=30%><TT>-V</TT></TD>
<TD width=70%>Проверять процесс сжатия. В данном случае <B><TT>flac</TT></B> создает параллельный декодер, раскодирующий выход кодера и сравнивает результат с оригиналом. Если будет найдено несоответствие, кодирование прекратится. Время работы с этой опцией увеличивается, однако, при этом гарантируется, что файл будет правильно декодирован.</TD></TR>

<TR><TD><TT>--lax</TT></TD>
<TD>Позволяет кодеру создавать файлы, отвечающие подмножеству формата FLAC. В результате работы будет получаться непотоковый файл, поэтому этот ключ следует использовать только для архивирования. Декодер будет поддерживать воспроизведение и поиск в таких файлах.</TD></TR>


<TR><TD><TT>--replay-gain</TT></TD>
<TD>Вычислить значения <A HREF="http://www.replaygain.org/">ReplayGain</A> и сохранить из в комментариях Vorbis, аналогично тому, как это делает <A HREF="http://packages.qa.debian.org/v/vorbisgain.html">VorbisGain</A>. Уровень записи и максимальные значения амплитуды будут вычислены для каждого входного файла. Кроме того будет рассчитаны значения для всего альбома (всех входных файлов). Для этого все файлы должны иметь одинакоыую частоту дискретизации, разрешение и число каналов. Допустимы только моно и стерео файлы, а частота дискретизации должна быть 8, 11.025, 12, 16, 22.05, 24, 32, 44.1 или 48 кГц. Обратите внимание на то, что для этой опции может понадобиться несколько дополнительных байтов в блоке PADDING, так как точный размер блока нельзя вычислить, пока не будут обработаны все файлы.<BR>
Обратите внимание на то, что эту возможность нельзя использовать при кодировании в стандартный вывод.</TD></TR>

<TR><TD><TT>--cuesheet=ИМЯ_ФАЙЛА</TT></TD>
<TD>Импортировать указанный список разбиения аудиодиска и сохранить его в блоке метаданных <A HREF="format.html#def_CUESHEET">CUESHEET</A>. Эту опцию можно использовать только при кодировании одного файла. Точки поиска будут добавлены для каждого трека из списка в блок <A HREF="format.html#def_SEEKTABLE">SEEKTABLE</A>, если не будет указана опция <TT>--no-cued-seekpoints</TT>.<BR>
Файл списка разбиения аудиодиска должен иметь такой же вид, в каком его создают программы <A HREF="http://www.goldenhawk.com/cdrwin.htm">CDRwin</A>, <A HREF="http://www.dcsoft.com/prod03.htm">CDRcue</A>, <A HREF="http://www.exactaudiocopy.de/">EAC</A> и т.д</TD></TR>


<TR><TD><TT>--sector-align</TT></TD>
<TD>
<P>При кодировании нескольких WAVE файлов, полученных с аудиодиска, выравнивать их на границу сектора. Эта опция применима только для кодирования нескольких WAVE файлов, каждый из которых должен иметь частоту дискретизации 44.1 кГц и два канала. Если будет указана эта опция кодер выровняет потоки .flac так,
что их длины будут кратны размеру сектора CD-Audio (равны 1/75 секундам или 588 сэмплам). Это осуществляется переносом части сектора в конце каждого WAVE файла в начало следующего. Последний поток будет дополнен до границы выравнивания нулями.</P>
<P>Использование этой опции не приведет ни к чему, если файлы уже выровнены (например, если правильно скопированы с аудиодиска). <TT><B>flac</B></TT> может выровнять только несколько файлов за один вызов.</P>

<P><B>ВНИМАНИЕ</B>: Порядок файлов имеет значение! Если вы сделаете следующий вызов '<TT>flac --sector-align *.wav</TT>', командный процессор может обработать шаблон не в том порядке, в каком вы рассчитываете. Поэтому лучше всего вызывать программу, явно указав список файлов, например, '<TT>flac --sector-align 8.wav 9.wav 10.wav</TT>'.
</TD></TR>

<TR><TD><TT>-S {#|X|#x|#s}</TT>,<BR><TT>--seekpoint={#|X|#x|#s}</TD>
<TD>Добавляет точки для поиска в таблицу <TT>SEEKTABLE</TT>.

<UL>
    <LI><TT>#&nbsp;</TT> : создается точка поиска для сэмпла с определенным номером.</LI>

    <LI><TT>X&nbsp;</TT> : резервируемые точки (всегда помещаются в конце <TT>SEEKTABLE</TT>).</LI>

    <LI><TT>#x</TT> : # равномерно распределенных точек поиска, первая соответствует 0 сэмплу.</LI>
    
    <LI><TT>#s</TT> : точки поиски расставляются для каждых # секунд; номер не обязательно должен быть целым числом, например, <TT>-S 9.5s</TT> ознчает, что точки будут проставлены с промежутком 9.5 секунд</LI>
</UL>

<P>Опцию <TT>-S</TT> можно использовать несколько раз. В результате получится объединенная таблица, в которой будут присутствовать только уникальные значения.<BR>
По умолчанию <B><TT>flac</TT></B> использует <TT>-S 10s</TT>. Если таблица поиска не нужна, укажите <TT>-S-</TT>.<BR>
<B>ПРИМЕЧАНИЕ</B>: <TT>-S #x</TT> и <TT>-S #s</TT> не будут работать, если кодер не сможет определить размер входного файла в начале работы.<BR>
<B>ПРИМЕЧАНИЕ</B>: если <I>#</I> больше или равен количеству сэмплов во входном файле, то точки добавлены не будут, если размер можно определить до кодирования, в противном случае будут записаны резервируемые точки.</P>
</TD></TR>

<TR><TD><TT>-P #</TT>, <TT>--padding</TT></TD>
<TD>Кодер запишет блок метаданных <TT>PADDING</TT>, указанного размера (в байтах), после блока <TT>STREAMINFO</TT>. Ключ <TT>--no-padding</TT> указывает, что блок <TT>PADDING</TT> не нужен (значение по умолчанию). Этот блок полезен, если вы собираетесь добавить тэг в файл позже. Вместо того, чтобы переписывать файл полностью, можно будет записать информацию вместо блока <TT>PADDING</TT>. Обратите внимание на то, что общий размер блока <TT>PADDING</TT> будет на 4 байта больше, так как 4 байта занимает заголовок.</TD></TR>

<TR><TD><TT>-T ПОЛЕ=ЗНАЧЕНИЕ</TT>, <TT>--tag=ПОЛЕ=ЗНАЧЕНИЕ</TT></TD>
<TD>Добавляет комментарии Vorbis, который должен соответствовать спецификации, т.е. ПОЛЕ должно содержать только определенные символы, завершающиеся знаком равенства. При необходимости не забывайте заключать комментарий в кавычки. Эту опцию можно использовать неоднократно для заполнения разных полей комментария. Все указанные значения будут применены ко всем кодируемым файлам.</TD></TR>

<TR><TD><TT>-b #</TT>, <TT>--blocksize</TT></TD>
<TD>Устанавливает размер блока в сэмплах. По умолчанию <TT>1152</TT> для <TT>-l 0</TT>, иначе <TT>4608</TT>. Стандартные потоки должны использовать одно из указаных значений: <TT>192/576/1152/2304/4608/256/512/1024/2048/4096/8192/16384/32768</TT>. Сейчас кодер использует постоянный размер блока для всего файла.</TD></TR>

<TR><TD><TT>-m</TT>, <TT>--mid-side</TT></TD>
<TD>Включает разностное кодирование (только для стерео потоков). Обычно увеличивает уровень сжатия на несколько процентов. Для каждого блока создается усредненная и стерео версия блока, сохраняется блок меньшего размера. Сейчас разностное кодирование доступно для файлов, где сэмпл имеет размер не больше 16 бит.</TD></TR>

<TR><TD><TT>-M</TT>, <TT>--adaptive-mid-side</TT></TD>
<TD>Включает адаптивное разностное кодирование (только для стерео потоков). Работает аналогично <TT>-m</TT>, однако кодер переключается между независимым и усредняющим кодированием адаптивно. Метод работает быстрее, но уровень сжатия меньше, так как <TT>-m</TT> производит полный перебор вариантов.</TD></TR>

<TR><TD><TT>-0..-8</TT></TD>
<TD>Быстрейшее сжатие ... максимальное сжатие. По умолчанию <TT>-5</TT>.</TD></TR>

<TR><TD><TT>-0</TT>, <TT>--compression-level-0</TT></TD>
<TD>Аналогично <TT>-l 0 -b 1152 -r 2,2</TT>.</TD></TR>

<TR><TD><TT>-1</TT>, <TT>--compression-level-1</TT></TD>
<TD>Аналогично <TT>-l 0 -b 1152 -r 2,2 -M</TT>.</TD></TR>

<TR><TD><TT>-2</TT>, <TT>--compression-level-2</TT></TD>
<TD>Аналогично <TT>-l 0 -b 1152 -r 3 -m</TT>.</TD></TR>

<TR><TD><TT>-3</TT>, <TT>--compression-level-3</TT></TD>
<TD>Аналогично <TT>-l 6 -b 4608 -r 3,3</TD></TR>

<TR><TD><TT>-4</TT>, <TT>--compression-level-4</TT></TD>
<TD>Аналогично <TT>-l 8 -b 4608 -r 3,3 -M</TT>.</TD></TR>

<TR><TD><TT>-5</TT>, <TT>--compression-level-5</TT></TD>
<TD>Аналогично <TT>-l 8 -b 4608 -r 3,3 -m</TT>.</TD></TR>

<TR><TD><TT>-6</TT>, <TT>--compression-level-6</TT></TD>
<TD>Аналогично <TT>-l 8 -b 4608 -r 4 -m</TT>.</TD></TR>

<TR><TD><TT>-7</TT>, <TT>--compression-level-7</TT></TD>
<TD>Аналогично <TT>-l 8 -b 4608 -r 6 -m -e</TT>.</TD></TR>

<TR><TD><TT>-8</TT>, <TT>--compression-level-8</TT></TD>
<TD>Аналогично <TT>-l 12 -b 4608 -r 6 -m -e</TT>.</TD></TR>

<TR><TD><TT>--fast</TT></TD>
<TD>Быстрейшее сжатие. Аналогично <TT>-0</TT>.</TD></TR>

<TR><TD><TT>--best</TT></TD>
<TD>Максимальное сжатие. Аналогично <TT>-8</TT>.</TD></TR>

<TR><TD><TT>-e</TT>,<BR><TT>--exhaustive-model-search</TT></TD>
<TD>Полный поиск модели (работает медленно!). Обычно кодер определяет лучшую модель и кодирует далее опираясь на нее. В данном режиме кодер будет создавать подфреймы всех порядков и использовать наименьший. Если максимальное значение порядка LPC велико, время кодирования существенно возрастет. Выигрыш обычно составляет около 0.5%.</TD></TR>

<TR><TD><TT>-E</TT>,<BR><TT>--escape-coding</TT></TD>
<TD>Использовать управляющие коды в кодере энтропии. Эта опция позволяет записывать незакодированное представление остатка в разделе, если его размер меньше. При этом время работы увеличивается, а уровень сжатия обычно улучшается примерно на 1%.</TD></TR>

<TR><TD><TT>-l #</TT>,<BR><TT>--max-lpc-order=#</TT></TD>
<TD>Определяет максимальный порядок LPC (коэффициентов линейного прогнозирования). Число должно быть меньше или равно <TT>32</TT>. Если значение равно <TT>0</TT>, кодер будет использовать вместо общего линейного прогнозирования постоянные коэффициенты. Этот метод увеличивает скорость работы, но файлы получаются на 5-10% больше.</TD></TR>

<TR><TD><TT>-q #</TT>,<BR><TT>--qlp-coeff-precision=#</TD>
<TD>Определяет точность дискретных коэффициентов линейного прогнозирования в битах. По умолчанию <TT>-q 0</TT>, что позволяет кодеру принимать решение в зависимости от сигнала. Лучше оставлять значение по умолчанию.</TD></TR>

<TR><TD><TT>-p</TT>,<BR><TT>--qlp-coeff-precision-search</TT></TD>
<TD>Производить оптимизацию LPC. Переопределяет любую опцию <TT>-q</TT>. Сильно замедляет работу, и уменьшает размер файла на долю процента. <TT>-q</TT> не работает, когда используется <TT>-l 0</TT>.</TD></TR>

<TR><TD><TT>-r [#,]#</TT>,<BR><TT>--rice-partition-order=[#,]#</TT></TD>
<TD>Установить <I>[min,]max</I> порядок раздела. Если минимальное значение не указано, то оно устанавливается равным 0. По умолчанию кодер один параметр Райса для всего остатка подфрейма. Если использовать эту опцию, остаток будет разделяться на <I>2^min#</I> ... <I>2^max</I> частей, для каждой из которых будет определен собственный параметр Райса. С увеличением параметра <I>max</I> выигрыш будет все меньше. Наиболее оптимальный вариант достигается при использовании <TT>-r 2,2</TT> (и больших значений для больших размеров блоков). При этом сжатие обычно увеличивается на 1.5%. Выбор оптимального значения можно произвести по формуле <TT>размер_блока/(2^n)=128</TT>. Максимальный уровень сжатия достигается при использовании <TT>-r 0,16</TT>.</TD></TR>
</TABLE>


<H4>Настройки формата</H4>
<TABLE border=1>
<TR><TD width=30%><TT>--endian={big|little}</TT></TD>
<TD width=70%>Определяет порядок байтов в файле без заголовка big-endian | little-endian.</TD></TR>

<TR><TD><TT>--channels=#</TT></TD>
<TD>Определяет количество каналов в файле без заголовка.</TD></TR>

<TR><TD><TT>--bps=#</TT></TD>
<TD>Определяет количество бит на сэмпл в файле без заголовка.</TD></TR>

<TR><TD><TT>--sample-rate=#</TT></TD>
<TD>Определяет количество сэмплов в секунду в файле без заголовка.</TD></TR>

<TR><TD><TT>--sign={signed|unsigned}</TT></TD>
<TD>Определяет, должны ли быть сэмплы в файле без заголовка беззнаковые или знаковые (по умолчанию знаковые).</TD></TR>

<TR><TD><TT>--force-aiff-format</TT></TD>
<TD>Декодер будет записывать в формат AIFF. Эта опция не нужна, если имя выходного файла (указанное с помощью ключа <TT>-o</TT>) заканчиватся на .aiff.</TD></TR>

<TR><TD><TT>--force-raw-format</TT></TD>
<TD>Воспринимать входной (или выходной при декодировании) файл как поток сэмплов без заголовка вне зависимости от суффикса.</TD></TR>
</TABLE>


<H4><a name="format-options">Отмена действия опций</H4>
<TABLE border=1>
<TR><TD width=40%>
<TT>--no-adaptive-mid-side</TT><BR>
<TT>--no-decode-through-errors</TT><BR>
<TT>--no-delete-input-file</TT><BR>
<TT>--no-escape-coding</TT><BR>
<TT>--no-exhaustive-model-search</TT><BR>
<TT>--no-lax</TT><BR>
<TT>--no-mid-side</TT><BR>
<TT>--no-ogg</TT><BR>
<TT>--no-padding</TT><BR>
<TT>--no-qlp-coeff-precision-search</TT><BR>
<TT>--no-residual-gnuplot</TT><BR>
<TT>--no-residual-text</TT><BR>
<TT>--no-sector-align</TT><BR>
<TT>--no-seektable</TT><BR>
<TT>--no-silent</TT><BR>
<TT>--no-verify</TT></TD>
<TD width=60%>Можно использовать для отключения действия конкретной опции.</TD></TR>
</TABLE>


<A NAME="metaflac">
<H3><B><TT>metaflac</TT></B></H3>

<P><B><TT>metaflac</TT></B> - это редактор метаданных, работающий из командной строки. Его можно использовать для удаления, вставки и вывода содержимого блоков во .flac файле, а также управления блоком<TT>PADDING</TT>, резервирующим место.</P>

<P>Документация для <B><TT>metaflac</TT></B> в формате HTML сейчас переписывается, поэтому сейчас о возможностях можно узнать, дав команду <TT>metaflac --help</TT> или ознакомиться со man-страницей.</P>

<A NAME="plugins"><A NAME="xmms_plugin">
<H3>Плагин для XMMS</H3>

<P>Для его установки необходимо скопировать <TT>libxmms-flac.so</TT> в каталог, где находятся плагины ввода XMMS (обычно <TT>/usr/lib/xmms/Input</TT>). Больше ничего настраивать не надо. Для воспроизведения .flac файлов перезапустите XMMS.</P>

<A NAME="winamp_plugin2">
<H3>Плагин для Winamp</H3>

<P>Есть два плагина для Winamp: один для версий 2.x, а второй для 3.x. Если вы используете Winamp 2.x, то для установки плагина необходимо скопировать <TT>in_flac.dll</TT> в каталог, где находятся плагины ввода Winamp (обычно <TT>/Plugins</TT>). Больше ничего настраивать не надо. Для воспроизведения .flac файлов перезапустите Winamp.</P>

<A NAME="winamp_plugin3">
<H3>Плагин для Winamp</H3>

<P>Есть два плагина для Winamp: один для версий 2.x, а второй для 3.x. Если вы используете Winamp 3.x, то для установки плагина необходимо скопировать <TT>cnv_flacpcm.wac</TT> в каталог, где находятся плагины ввода Winamp (обычно <TT>/Wacs</TT>). Больше ничего настраивать не надо. Для воспроизведения .flac файлов перезапустите Winamp.</P>

<A NAME="bugs">
<H3>Известные ошибки</H3>

<P>Отслеживание ошибок ведется на <A HREF="http://sourceforge.net/bugs/?group_id=13478">этой</A> странице проекта, находящейся на SourceForge. Если Вы будете сообщать об ошибке, пожалуйста, оставьте e-mail для контакта.</P>

<P>Ниже перечислены известные ошибки в текущей версии (1.1.0):</P>

<BLOCKQUOTE><UL>
	<LI>Нет известных ошибок.</LI>
</UL></BLOCKQUOTE>

<P>В версии 1.0.4 были следующие значимые ошибки:</P>

<BLOCKQUOTE><UL>
	<LI>Во всех декодерах до этой версии включительно была ошибка не позволяющая правильно пропускать неизвестные блоки метаданных. Файл FLAC, созданный кодером flac 1.1.0 и содержащий блок метаданных CUESHEET, не будет воспроизводиться более ранними версиями декодеров.</LI>
	<LI>В <B><TT>metaflac</TT></B> была ошибка, возникающая при импортировании комметария в формате Vorbis, которая могла привести к повреждению файла FLAC.</LI>
</UL></BLOCKQUOTE>


<A NAME="monkey">
<H3>monkey</H3>

<P>Monkey's Audio поставляется с удобным пользовательским интерфейсом. Он поддерживает несколько внешних кодеров, в число которых не входит FLAC. Однако дистрибутив FLAC для Windows поставляется с утилитой, позволяющей заменить один из поддерживаемых внешних кодеков на FLAC. Это можно сделать так:</P>

<UL>
<LI>Скопируйте <B><TT>flac.exe</TT></B> и <B><TT>flac_ren.exe</TT></B> в каталог <B><TT>External/</TT></B> установки Monkey's Audio.</LI>

<LI>Выберите, какой поддерживаемый кодер заменить:
    <UL>
    <LI>Shorten - скопируйте <B><TT>flac_mac.exe</TT></B> поверх <B><TT>External/shortn32.exe</TT></B></LI>
    <LI>WavPack - скопируйте <B><TT>flac_mac.exe</TT></B> поверх <B><TT>External/wavpack.exe</TT></B> и <B><TT>External/wvunpack.exe</TT></B></LI>
    <LI>RKAU - скопируйте <B><TT>flac_mac.exe</TT></B> поверх <B><TT>External/rkau.exe</TT></B></LI>
    </UL>
Если выбрать WavPack, то для изменения опций FLAC будет доступно меню настройки WavPack Configuration.</LI>
<LI>Теперь можно кодировать в формат FLAC. Переименованный файл <B><TT>flac_mac.exe</TT></B> вызывает <B><TT>flac.exe</TT></B>, а затем <B><TT>flac_ren.exe</TT></B> для присвоения получаемому файлу расширения .flac.</LI>
</UL>
</P>

<P>Другие оболочки можно использовать примерно таким же способом.</P>

<P>&nbsp;Copyright (c) 2000,2001,2002,2003,2004,2005,2006,2007  Josh Coalson</P>

</BODY>
</HTML>
