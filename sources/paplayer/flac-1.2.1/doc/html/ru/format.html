<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<!-- Copyright (c) 2000,2001,2002,2003,2004,2005,2006,2007  Josh Coalson -->
<!-- Permission is granted to copy, distribute and/or modify this document -->
<!-- under the terms of the GNU Free Documentation License, Version 1.1 -->
<!-- or any later version published by the Free Software Foundation; -->
<!-- with no invariant sections. -->
<!-- A copy of the license can be found at http://www.gnu.org/copyleft/fdl.html -->
<HTML>
<HEAD>
<META CHARSET="windows-1251">
<TITLE>FLAC: формат</TITLE>
</HEAD>

<BODY>
<CENTER><TABLE cellpadding=0 cellspacing=0 border=0>
<TR>
<TD align=center>|</TD>
<TD height=22 align=center nowrap>
&nbsp;<A HREF="index.html">начало</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="news.html">новости</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="download.html">файлы</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="features.html">характеристики</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="goals.html">цели</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;формат&nbsp;</TD>
<TD align=center>|</TD></TR>

<TR>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="id.html">id</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="comparison.html">сравнение</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="developers.html">разработка</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="documentation.html">документация</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="links.html">ссылки</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="authors.html">авторы</A>&nbsp;</TD>
<TD align=center>|</TD></TR>
</TABLE></CENTER>

<P><CENTER><TABLE cellpadding=0 cellspacing=0 border=0>
<TR><TD align=center>|</TD>
<TD height=22 align=center nowrap>
&nbsp;<A HREF="../format.html">english</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;русский</A>&nbsp;</TD>
<TD align=center>|</TD></TR>
</TABLE></CENTER></P>


<CENTER><H2>FLAC: формат</H2></CENTER>


<H3>Формат</H3>

<P>Здесь приведено полное описание формата FLAC.</P>


<H4>От автора</H4>

<P>Во-первых, как основной разработчик, я должен отметить, что не являюсь экспертом в области сжатия, поэтому чувствую себя обязанным поблагодарить многих людей, работавших над улучшением алгоритмов компрессии аудиоданных. Отдельную благодарность я выражаю:</P>

<P><BLOCKQUOTE>
<LI><A HREF="http://www-svr.eng.cam.ac.uk/reports/abstracts/robinson_tr156.html">Э. Робинсону</A> за работу над Shorten. Его статья послужила отправной точкой для нескольких основных методов, заложенных во FLAC. FLAC развил идею постоянных предикторов, используемую в Shorten.</LI>

<LI><A HREF="http://commsci.usc.edu/faculty/golomb.html">С. Голомбу</A> и Роберту Райсу. Их универсальные коды используются кодером энтропии.</LI>

<LI>Н. Левинсону и Дж. Дарбину. Базовый кодер использует разработанный и улучшенный ими алгоритм для определения LPC коэффициентов из коэффициентов автокорреляции.</LI>

<LI>И, конечно же, <A HREF="http://www.digitalcentury.com/encyclo/update/shannon.html">К. Шеннону.</A></LI>
</BLOCKQUOTE></P>

<P>--Джош Колсон</P>


<a name="scope">
<H4><u>Область применения</u></H4>

<P>Общеизвестно, что нет алгоритма, способного сжать без потерь входные данные любого типа. Большинство архиваторов позиционируются для работы с данными определенного вида и оптимизируются для этой области. FLAC предназначен для сжатия аудиоданных. Несмотря на то, что он может сжать без потерь данные любого типа, только определенный ввод архивируется хорошо. FLAC использует тот факт, что обычно аудиоданные имеют высокий порядок корреляции между сэмплами.</P>

<P>В области аудио существует множество возможных подразделов. Например, речь с низким битрейтом, многоканальная музыка с высокой частотой дискретизации и т.д. FLAC не нацелен на какой-либо подраздел, однако большинство параметров по умолчанию базового кодера рассчитаны на CD-аудио (т.е. 44.1кГц, 2 канала, 16 бит на сэмпл). Влияние параметров кодирования на разные типы аудио будет рассмотрено позже.</P>

<a name="architecture">
<H4><u>Архитектура</u></H4>

<P>Подобно большинству программ такого рода, кодер FLAC выполняет следующие действия:</P>

<P><BLOCKQUOTE>
<LI><A HREF="format.html#blocking">Разбиение на блоки</A>. Ввод разбивается на множество последовательных блоков, которые могут иметь различный размер. Оптимальный размер блока обычно зависит от многих факторов, таких как частота дискетизации, спектральная характеристика во времени и т.д. Несмотря на то, что формат FLAC позволяет использовать в потоке блоки различного размера, базовый кодер использует постоянный размер.</LI>

<LI><A HREF="format.html#interchannel">Межканальная декорреляция</A>. В случае стереопотоков кодер создает средний и разностный сигналы, основанные на среднем значении между левым и правым каналами и их разности соответственно. На следующий этап кодирования передается лучший из вариантов сжатого сигнала.</LI>

<LI><A HREF="format.html#prediction">Прогнозирование</A>. Далее кодер пытается найти математическое описание сигнала (обычно приблизительное). Зачастую оно значительно меньше самого сигнала. Так как методы предсказания известны и кодеру, и декодеру в потоке нужно указать только параметры предиктора. Сейчас FLAC использует четыре различных класса предикторов (описанных в разделе <A HREF="format.html#prediction">Прогнозирование</A>), но в формате предусмотрено место для дополнительных методов. FLAC допускает изменение класса предиктора от блока к блоку и даже в пределах канала в блоке.</LI>

<LI><A HREF="format.html#residualcoding">Кодирование остатков</A>. Если предиктор не описывает сигнал точно, разница между оригинальным сигналом и спрогнозированным (называемым еще ошибочным или остаточным) должна быть закодирована без потерь. Если предсказание эффективно, остаточный сигнал будет занимать меньше бит на сэмпл, чем оригинальный сигнал. Сейчас FLAC использует только один метод для кодирования остатков (см. раздел <A HREF="format.html#residualcoding">Кодирование остатков</A>), однако в формате предусмотрено место для дополнительных методов. FLAC допускает изменение метода кодирования остатков от блока к блоку и даже в пределах канала в блоке.</LI>
</BLOCKQUOTE></P>

<P>В дополнение ко всему определена система метаданных, позволяющая добавлять в начало потока произвольную информацию.</P>


<a name="definitions">
<H4><u>Определения</u></H4>

<P>Многие термины, такие как "блок" и "фрейм", имеют различное значение в схемах кодирования. Например, фрейм в mp3 сооветствует многим сэмплам во всех каналах, в то время как фрейм S/PDIF представляет только один сэмпл для каждого канала. Обратите внимание на то, что, говоря о "блоках" и "подблоках", мы ссылаемся на незакодированные аудиоданные, а термины "фрейм" и "подфрейм" используем для данных сжатых FLAC.</P>

<P><BLOCKQUOTE>
<LI><B>Блок</B> - это один или более сэмплов, находящихся в нескольких каналах.</LI>

<LI><B>Подблок</B> - это один или более сэмплов из одного канала. Таким образом, блок содержит подблок для каждого канала и все подблоки в нем содержат одинаковое количество сэмплов.</LI>

<LI><B>Размер блока</B> - это количество сэмплов в любом из своих подблоков. Например, блок длиной в одну секунду с частотой дескретизации 44.1кГц имеет размер блока 44100 вне зависимости от количества каналов.</LI>

<LI><B>Фрейм</B> - это заголовок и один или несколько подфреймов.</LI>

<LI><B>Подфрейм</B> - это заголовок и один или несколько закодированных сэмплов из данного канала. Все подфреймы в данном фрейме содержат одинаковое количество сэмплов.</LI>
</BLOCKQUOTE></P>


<a name="blocking">
<H4><u>Разбиение на блоки</u></H4>

<P>Размер блоков сильно влияет на уровень сжатия. Если размер блока будет слишком мал, то в итоге получится очень много фреймов, а это значит, что на заголовки будет потрачено много битов. Если же размер блока большой, а характеристики сигнала сильно варьируются, кодер не сможет найти хороший предиктор. Чтобы упростить кодек, FLAC определяет минимальный размер блока в 16 сэмплов, а максимальный в 65535 сэмплов. Этот интервал покрывает оптимальные размеры блоков для всех аудиоданных, поддерживаемых FLAC.</P>

<P>Сейчас базовый кодер использует постоянный размер блока, оптимизированный по частоте дискретизации ввода. Последующие версии смогут изменять размер блока в зависимости от характеристик сигнала.</P>

<P>Разбитые на блоки данные передаются на стадию прогнозирования по одному подблоку. Каждый подблок кодируется в подфрейм независимо, а позже они объендиняются во фрейм. Так как каждый канал кодируется отдельно, это означает, что один канал стерео фрейма может сжиматься как постоянный подфрейм, а второй как LPC подфрейм.</P>


<a name="interchannel">
<H4><u>Межканальная декорреляция</u></H4>

<P>В большинстве случаев в стерео потоках существует достаточный уровень корреляции между левым и правым каналами. FLAC позволяет фреймам в стерео потоках иметь различное распределение каналов, а кодер может использовать лучшее представление.</P>

<P><BLOCKQUOTE>
<LI><B>Независимое</B>. Левый и правый каналы кодируются независимо.</LI>

<LI><B>Разностное</B>. Левый и правый канал преобразовываются в средний и остаточный каналы. Средний канал - это среднее значение левого и правого сигналов, а остаточный - разница между ними (левый минус правый).</LI>

<LI><B>Левостороннее</B>. Кодируется левый и остаточный каналы.</LI>

<LI><B>Правоостороннее</B>. Кодируется правый и остаточный каналы.</LI>
</BLOCKQUOTE></P>

<P>Оказывается, что левостороннее и правостороннее кодирование могут быть более эффективными во многих фреймах, несмотря на то, что необходимое для оригинального сигнала количество битов на сэмпл немного больше, чем для независимого или усредненного кодирования.</P>


<a name="prediction">
<H4><u>Прогнозирование</u></H4>

<P>FLAC использует четыре метода для моделирования входного сигнала:</P>

<P><BLOCKQUOTE>
<LI><B>Дословный</B>. По существу это прогнозирование сигнала нулевого уровня. Предиктором сигнала является сам сигнал, потому сжатие не происходит. Это образец, с которым сверяются все остальные предикторы. Если передать кодеру случайные данные, для всех подблоков скоре всего будет использован дословный предиктор. Так как необработанный сигнал не проходит стадию кодирования остатков, результаты не будут совпадать с линейным предиктором нулевого порядка.</LI>

<LI><B>Постоянный</B>. Этот предиктор используется, когда подблок содержит цифровую тишину, т.е. на вход поступает одна константа. Сигнал кодируется по всей длине и добавляется к потоку.</LI>

<LI><B>Постоянный линейный предиктор</B>. FLAC использует класс эффективно вычисляемых постоянных линейных предикторов (хорошее описание приведено у <A HREF="http://svr-www.eng.cam.ac.uk/~ajr/GroupPubs/Robinson94-tr156/index.html">Shorten</A> и <A HREF="http://www.hpl.hp.com/techreports/1999/HPL-1999-144.pdf">AudioPak</A>). FLAC добавляет предиктор четвертого уровня к использованным в Shorten предикторам от нулевого до третьего уровня. Так как предикторы постоянны, в сжатом потоке необходимо сохранить только порядок предиктора. Остаточный сигнал передается кодеру остатков.</LI>

<LI><B>Линейное прогнозирование FIR</B>. Для более точного моделирования (за счет медленной работы) FLAC поддерживает линейное прогнозирование FIR до 32 порядка (см. <A HREF="http://svr-www.eng.cam.ac.uk/~ajr/GroupPubs/Robinson94-tr156/index.html">Shorten</A> и <A HREF="http://www.hpl.hp.com/techreports/1999/HPL-1999-144.pdf">AudioPak</A>). Базовый кодер использует метод Левинсона-Дарбина для расчета LPC коэффициентов из коэффициентов автокорреляции и коэффициенты разбиваются перед вычислением остатков. В то время как такие кодеры как Shorten используют постоянное разбиение для всего ввода, FLAC позволяет для каждого фрейма менять точность коэффициента разбиения. Базовый кодер FLAC оценивает оптимальную точность, основываясь на размере блока и диапазоне оригинального сигнала.</LI>
</BLOCKQUOTE></P>

<a name="residualcoding">
<H4><u>Кодирование остатков</u></H4>

<P>Для кодирования остаточного сигнала от стадии прогнозирования FLAC использует два похожих метода. Остаточный сигнал сжимается с использованием кодов Райса следующими способами:</P>

<BLOCKQUOTE><ol>
<LI>Кодер оценивает одиночный параметр Райса, основанный на разнице остатка и кодов Райса. Весь остаток кодируется с использованием этого параметра.</LI>

<LI>Остаток делится на несколько интервалов одинаковой длины и каждый из них кодируется со своим параметром Райса, основанным на среднем значении для данного интервала.</LI>
</ol></BLOCKQUOTE>

<P>Обратите внимание на то, что первый метод является частным случаем второго с одним интервалом. Отличие состоит в том, что в первом методе параметр Райса вычисляется для разницы остатка, а не для среднего значения.</P>

<P>В формате FLAC зарезервировано место для других методов кодирования. Кто-нибудь может попытаться найти лучшее контекстное моделирование параметра Райса или кодирования Хаффмана. Описания нескольких универсальных кодов можно найти на страницах <A HREF="http://www.hpl.hp.com/techreports/98/HPL-98-193.html">LOCO-I</A> и <A HREF="http://www.cs.tut.fi/~albert/Dev/pucrunch/packing.html">pucrunch</A>.</P>


<a name="prediction">
<H4><u>Формат</u></H4>

<P>В этом разделе описывается формат файла. Формат FLAC не предусматривает поля для номера версии, однако содержит несколько зарезервированных позиций. Последующие версии смогут использовать это место без нарушения совместимости с предыдущими версиями. Более старые версии декодеров могут либо прекращать работу, либо пропускать данные, закодированные новыми методами. Кроме того зарезервированы некоторые специальные значения, которые не могут появиться ни в одной из версий формата. Это обычно делается для улучшения механизма синхронизации.</P>

<P>Все числа в формате FLAC являются целыми, младший байт которых записывается вначале (big-endian). Числа являются беззнаковыми, кроме тех случаев, где явно указано обратное.</P>

<a name="overview">
<P>К потоку FLAC могут быть добавлены тэги ID3v1 (в конце) и ID3v2 (в начале). Эти данные не относятся к формату, однако декодер умеет пропускать их.</P>

<P>Перед полным описанием формата приведем его краткий обзор.</P>

<P><BLOCKQUOTE>
<LI>Формат FLAC состоит из маркера "fLaC" в начале потока, за которым следует обязательный блок STREAMINFO, любое количество других блоков метаданных, а затем аудиофреймы.</LI>

<LI>FLAC поддерживает до 128 блоков метаданных. Сейчас определены:</LI>

<UL>
<A NAME="def_STREAMINFO">
<LI><TT>STREAMINFO</TT>: Этот блок содержит информацию обо всем потоке (частоту дискретизации, количество каналов, количество сэмплов и т.д.). Он всегда должен быть первым блоком метаданных в потоке. Следующие блоки должны следовать за ним, и могут быть пропущены декодером.</LI>

<A NAME="def_APPLICATION">
<LI><TT>APPLICATION</TT>: Этот блок предназначен для использования приложениями третьих лиц. Единственным обязательным полем является 32-битный идентификатор, который выдается разработчиками FLAC. Формат оставшейся части блока определяется зарегистрированным под этим номером приложением. Чтобы получить id для своего приложения, посетите <A HREF="id.html">страницу регистрации</A>.</LI>

<A NAME="def_PADDING">
<LI><TT>PADDING</TT>: Этот блок предназначен для резервирования места. Содержимое блока <TT>PADDING</TT> не имеет значения. Он полезен в том случае, если известно, что блок после кодирования будет добавлен блок <TT>APPLICATION</TT>. Пользователь может зарезервировать необходимое пространство с помощью блока <TT>PADDING</TT>, чтобы приложение смогло записать на его место блок <TT>APPLICATION</TT>. Эта операция займет намного меньше времени, чем вставка блока в начало файла, так как в втором случае потребуется его полная перезапись.</LI>

<A NAME="def_SEEKTABLE">
<LI><TT>SEEKTABLE</TT>: Это необязательный блок для хранения точек поиска. В потоке FLAC можно найти любой сэмпл без этой таблицы, однако задержка может быть непредсказуемой, так как битрейт в потоке может существенно меняться. С помощью таблицы точек поиска пауза может быть существенно сокращена. Каждая точка занимает 18 байтов, поэтому для быстрого поиска с точностью до 1% необходимо всего 2кб. В потоке может быть только одни блок <TT>SEEKTABLE</TT>, но в нем может быть любое количество точек поиска. Также существуют резервируемые точки, которые пропускаются декодером, но могут использоваться для последующих вставок реальных точек поиска.</LI>

<A NAME="def_VORBIS_COMMENT">
<LI><TT>VORBIS_COMMENT</TT>: Этот блок предназначен для хранения списка в удобном для чтения формате (параметр=значение). Значения записываются в кодировке UTF-8. Используется реализация <A HREF="http://xiph.org/ogg/vorbis/doc/v-comment.html">спецификации комментария Vorbis</A>. Это единственный официально поддерживаемый механизм работы с тегами в FLAC. В потоке может быть только один блок <TT>VORBIS_COMMENT</TT>.</LI>

<A NAME="def_CUESHEET">
<LI><TT>CUESHEET</TT>: В этом блоке записывается информация из списка разбиения аудиодиска. Сделана поддержка треков и индекса, совместимая со стандартом Red Book CD для аудиодисков, а также других метаданных, таких как номер в каталоге дисков. Этот блок особенно полезен для архивирования аудиодисков, но также может использоваться как механизм для поиска при воспроизведении.</LI>
</UL>

<LI>Аудиопоток состоит из одного или нескольких фреймов. У каждого фрейма есть заголовок, состоящий из кода синхронизации, информации о фрейме (размер блока, частота дискретизации, количество каналов и т.п.) и восьмибитной контрольной суммы. Также в заголовке содержится либо номер первого сэмпла во фрейме относительно всего потока (для потоков с изменяющимся размером блока) или номер фрейма (для потоков с постоянным размером блока). Это позволяет производить быстрый и точный поиск. Далее следуют закодированные подфреймы (по одному на каждый канал) и, наконец, фрейм, дополненный нулями до границы байта. Каждый подфрейм имеет свой заголовок, определяющий способ его декодирования.</LI>

<LI>Так как декодер может начать работу в середине потока, должен быть метод определения начала фрейма. Каждый фрейм начинается с 14-битного синхронизирующего кода. Этот код не может появляться ни в одном другом месте заголовка фрейма. Однако так как это код может появиться в подфреймах, у декодера есть два способа определить, что данная последовательность является началом фрейма. Сначала проверяется корректность данных во всем фрейме. Однако этот шаг не может гарантировать отсутствия ошибок, поэтому дополнительно производится расчет восьмибитной контрольной суммы заголовка фрейма и полученный результат сравнивается со значением, полученным при кодировании и записанным после заголовка фрейма.</LI>

<LI>Каждый фрейм должен содержать основную информацию о потоке, так как декодер может не иметь доступа к блоку метаданных <TT>STREAMINFO</TT> в начале потока. Сюда входит частота дискретизации, количество бит на сэмпл, количество каналов и т.д. Так как заголовоки фреймов вносят дополнительные накладные расходы, то они влияют уровень сжатия. Чтобы сделать заголовки фреймов минимальными, FLAC использует таблицы поиска для наиболее часто используемых значений параметров фремов. Например, часть, отвечающая за частоту дискретизации, занимает 4 бита. Восемь предопределенных значений соответствуют наиболее самым распространенным частотам (8/16/22.05/24/32/44.1/48/96 кГц). Однако дополнительные частоты могут быть использованы с помощью специального набора битов, указывающего декодеру, что необходимое значение находится в конце заголовка. Такой же метод используется для указания размера блока и количества битов на сэмпл. В этом случае заголовок остается достаточно малым для наиболее распространенных типов аудиоданных.</LI>

<LI>Подфреймы (по одному для каждого канала) кодируются во фрейме отдельно и хранятся в потоке последовательно. Это ведет к упрощению декодера, однако ценой этому является увеличение размеров буффера. У каждого подфрейма есть свой заголовок, определяющий его аттрибуты (метод и порядок прогнозирования, параметры кодирования остатков и т.д.). За заголовком следуют аудиоданные для этого канала.</LI>

<A NAME="subset">
<LI>Во FLAC определено специальное подмножество формата (Subset format). Все потоки сжатые этим методом на самом деле являются потоковыми, то есть декодер, который не может искать в потоке, имеет возможность перейти к любой его точке и начать воспроизведение. Для файлов, отвечающих этому подмножеству формата, значительно проще сделать аппаратный декодер. <B><TT>flac</TT></B> по умолчанию создает потоки, отвечающие этому подмножеству формата. Ключ <TT>--lax</TT> запрещает создание таких потоков. Чтобы файл отвечал данному подмножеству, для него должны выполняться следующие ограничения:</LI>

    <UL>
        <LI>Значение битов, отвечающих за размер блока, должно быть в пределах 0001-0101 или 1000-1110. Поток должен состоять из блоков одинакового небольшого размера (за исключением последнего), а в блоке метаданных <TT>STREAMINFO</TT> должны быть указаны равные значения для минимального и максимального размера блока.</LI>
        <LI>Частота дискретизации в заголовке фрейма должна описываться следующим диапазоном битов 0001-1011.</LI>
	<LI>Количество бит на сэмпл в заголовке фрейма должно описываться следующим диапазоном битов 001-111.</LI>
    </UL>
</BLOCKQUOTE></P>

<P>В таблице приведено формальное описание формата FLAC. Числа в угловых скобках показывают количество битов, используемых данным полем.</P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
    <TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="stream"><FONT SIZE="+2"><B><TT>ПОТОК</TT></B></FONT></A></TD>
</TR>

<TR>
    <TD VALIGN="TOP">&lt;32&gt;</TD>
    <TD>"fLaC", маркер потока FLAC в кодировке ASCII, означающий, что первыми четырьмя байтами потока являются 0x66, 0x4C, 0x61, 0x43</TD>
</TR>

<TR>
    <TD VALIGN="TOP"><A HREF="format.html#metadata_block_streaminfo"><TT>БЛОК_МЕТАДАННЫХ</TT></A></TD>
    <TD>Обязательный блок метаданных <TT>STREAMINFO</TT>, содержащий основные свойства потока</TD>
</TR>

<TR>
    <TD VALIGN="TOP"><A HREF="format.html#metadata_block"><TT>БЛОК_МЕТАДАННЫХ</TT></A>*</TD>
  	<TD>Ноль или больше блоков метаданных</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#frame"><TT>ФРЕЙМ</TT></A>+</TD>
	<TD>Один или больше аудиофреймов</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block"><FONT SIZE="+2"><B><TT>БЛОК_МЕТАДАННЫХ</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#metadata_block_header"><TT>ЗАГОЛОВОК_БЛОКА_МЕТАДАННЫХ</TT></A></TD>
	<TD>Заголовок, определяющий тип и размер блока метаданных</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#metadata_block_data"><TT>СОДЕРЖИМОЕ_БЛОКА_МЕТАДАННЫХ</TT></A></TD>
	<TD>&nbsp;</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_header"><FONT SIZE="+2"><B><TT>ЗАГОЛОВОК_БЛОКА_МЕТАДАННЫХ</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;1&gt;</TD><TD>Флаг равный <TT>1</TT>, если данный блок метаданных является последним перед аудиоблоками, <TT>0</TT> в противном случае</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;7&gt;</TD>
	<TD>Тип блока:
	<UL>
		<LI>0 : <TT>STREAMINFO</TT></LI>
		<LI>1 : <TT>PADDING</TT></LI>
		<LI>2 : <TT>APPLICATION</TT></LI>
		<LI>3 : <TT>SEEKTABLE</TT></LI>
		<LI>4 : <TT>VORBIS_COMMENT</TT></LI>
		<LI>5 : <TT>CUESHEET</TT></LI>
		<LI>6-127 : зарезервированы</LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;24&gt;</TD>
	<TD>Длина в байтах соответствующего блока метаданных (не включает размер <TT>ЗАГОЛОВКА_БЛОКА_МЕТАДАННЫХ</TT>)</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_data"><FONT SIZE="+2"><B><TT>СОДЕРЖИМОЕ_БЛОКА_МЕТАДАННЫХ</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#metadata_block_streaminfo"><TT>БЛОК_МЕТАДАННЫХ_STREAMINFO</TT></A> || <A HREF="format.html#metadata_block_padding"><TT>БЛОК_МЕТАДАННЫХ_PADDING</TT></A> || <A HREF="format.html#metadata_block_application"><TT>БЛОК_МЕТАДАННЫХ_APPLICATION</TT></A> || <A HREF="format.html#metadata_block_seektable"><TT>БЛОК_МЕТАДАННЫХ_SEEKTABLE</TT></A> || <A HREF="#metadata_block_vorbis_comment"><TT>БЛОК_МЕТАДАННЫХ_VORBIS_COMMENT</TT></A> || <A HREF="#metadata_block_cuesheet"><TT>METADATA_BLOCK_CUESHEET</TT></A></TD>
	<TD>Содержимое блока должно соответствовать типу блока, указанному в заголовке</TD>
</TR>

</TABLE></P>

<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_streaminfo"><FONT SIZE="+2"><B><TT>БЛОК_МЕТАДАННЫХ_STREAMINFO</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;16&gt;</TD>
	<TD>Минимальный размер блока в сэмплах в данном потоке.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;16&gt;</TD>
	<TD>Максимальный размер блока в сэмплах в данном потоке.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;24&gt;</TD>
	<TD>Минимальный размер фрейма в байтах в данном потоке. Если значение не известно, то <TT>0</TT></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;24&gt;</TD>
	<TD>Максимальный размер фрейма в байтах в данном потоке. Если значение не известно, то <TT>0</TT></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;20&gt;</TD>
	<TD>Частота дискретизации в Гц.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;3&gt;</TD>
	<TD><TT>(Количество каналов) - 1</TT>. FLAC поддерживает от 1 до 8 каналов.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;5&gt;</TD>
	<TD><TT>(Количество битов на сэмпл) - 1</TT>. FLAC поддерживает от 1 до 32 битов на сэмпл. Сейчас базовые декодер и кодер поддерживают до 24 бит на сэмпл.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;36&gt;</TD>
	<TD>Количество сэмплов в потоке. Если здесь указан <TT>0</TT>, то количество сэмплов не известно.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;128&gt;</TD>
	<TD>Подпись MD5 несжатых аудиоданных, которая позволяет декодеру обнаружить ошибку, даже если ее наличие не нарушает структуру потока.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&nbsp;</TD>
	<TD><B>Примечания</B>:
	<UL>
		<LI>Во FLAC определен минимальный размер блока в <TT>16</TT> сэмплов и максимальный размер - <TT>65535</TT>. Это значит, что значения от <TT>0</TT> до <TT>15</TT> в соответствующих полях являются ошибочными.</LI>
	</UL>
	</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_padding"><FONT SIZE="+2"><B><TT>БЛОК_МЕТАДАННЫХ_PADDING</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;n&gt;</TD>
	<TD><TT>n</TT> бит со значением <TT>0</TT>. <TT>n</TT> должно быть кратно 8.</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_application"><FONT SIZE="+2"><B><TT>БЛОК_МЕТАДАННЫХ_APPLICATION</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;32&gt;</TD>
	<TD>Зарегистрированный id приложения (см. страницу <A HREF="id.html">регистрации</A>)</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;n&gt;</TD>
	<TD>Данные приложения. <TT>n</TT> должно быть кратно 8.</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_seektable"><FONT SIZE="+2"><B><TT>БЛОК_МЕТАДАННЫХ_SEEKTABLE</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#metadata_block_seekpoint"><TT>SEEKPOINT</TT></A>+</TD>
	<TD>Одна или больше точек поиска.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&nbsp;</TD>
	<TD><B>Примечания</B>:
	<UL>
		<LI>Количество точек поиска определяется в поле заголовка блока метаданных &quot;длина&quot; и равно <TT>длина / 18</TT>.</LI>
	</UL>
	</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_seekpoint"><FONT SIZE="+2"><B><TT>БЛОК_МЕТАДАННЫХ_SEEKPOINT</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;64&gt;</TD>
	<TD>Номер сэмпла в потоке первого сэмпла целевого фрейма или 0xFFFFFFFFFFFFFFFF для зарезервированной точки.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;64&gt;</TD>
	<TD>Смещение в байтах от первого байта первого заголовка фрейма до первого байта заголовка целевого фрейма.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;16&gt;</TD>
	<TD>Количество сэмплов в целевом фрейме.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&nbsp;</TD>
	<TD><B>Примечания</B>:
	<UL>
		<LI>Для зарезервированных точек значения второго и третьего поля не определены.</LI>
		<LI>Точки поиска должны быть отсортированы в таблице по возрастанию номера сэмпла.</LI>
		<LI>Поля, содержащие номера первых сэмплов в целевом фрейме, должны быть уникальны для всех точек, за исключением зарезервированных.</LI>
		<LI>Из двух предыдущих замечаний следует, что зарезервированных точек может быть любое количество, но они должны располагаться в конце таблицы.</LI>
	</UL>
	</TD>
</TR>
</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_vorbis_comment"><FONT SIZE="+2"><B><TT>БЛОК_МЕТАДАННЫХ_VORBIS_COMMENT</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;n&gt;</TD>
	<TD>Содержимое комметария в формате Vorbis, как оно описано <A HREF="http://www.xiph.org/ogg/vorbis/doc/v-comment.html">здесь</A>. Обратите внимание на то, что спецификация Vorbis ограничивает размер этого блока 2 ^ 64 байтами, в то время как блок метаданных FLAC может иметь размер не больше 2 ^ 24 байтов. В соответствии со спецификацией Vorbis 32-битные данные, записанные в прямом порядке, в отличие от целых, записанных в обратном порядке, используемых в остальных частях FLAC.</TD>
</TR>
</TABLE></P>

<P><TABLE WIDTH="100%" BORDER="1">

<TR>
<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="metadata_block_cuesheet"><FONT SIZE="+2"><B><TT>БЛОК_МЕТАДАННЫХ_CUESHEET</TT></B></FONT></A></TD>
</TR>


<TR>
<TD>&lt;128*8&gt;</TD>
<TD>Номер в мультимедийном каталоге, в котором используются только символы ASCII из диапазона 0x20-0x7e. В общем случае этот номер может иметь размер от 0 до 128 байтов, а символы справа, оставшиеся неиспользованными, должны быть заполнены байтом 0x00. На аудиодисках номер состоит из 13 цифр, за которыми следуют 115 пустых символов.</TD></TR>

<TR>
<TD>&lt;64&gt;</TD>
<TD>Количество начальных сэмплов. Это поле имеет значение только для оглавлений аудиодисков, для остальных целей должно быть установлено значение 0. Для аудиодисков начальной является зона помеченная как TRACK 00, где хранится оглавление. Более точно определение для данного поля выглядело бы так: это число сэмплов от первого сэмпла на диске до первого сэмпла превой индексной точки первого трека. В соответствии со стандартом Red Book начальная зона должна содержать тишину, поэтому программы для копирования с аудиодиска обычно не сохраняют ее. Кроме того начальная зона должна занимать не меньше двух секунд. Поэтому здесь хранится длина начальной зоны, чтобы потом моджно было вычислить абсолютную позицию первого трека. Обратите внимание на то, что число сэмплов указывается до первой индексной точки первого трека, а не обязательно до точки INDEX 01 первого трека, так как на первом треке могут быть данные с индексом INDEX 00.</TD></TR>

<TR>
<TD>&lt;1&gt;</TD>
<TD><TT>1</TT>, если CUESHEET соответствует компакт диску, иначе <TT>0</TT>.</TD></TR>

<TR>
<TD>&lt;7+258*8&gt;</TD>
<TD>Зарезервировано. Все биты должны быть равны 0.</TD></TR>

<TR>
<TD>&lt;8&gt;</TD>
<TD>Количество треков. Для аудиодисков это число должно быть не больше, чем 100 (99 обычных треков и завершающий трек).</TD></TR>

<TR>
<TD><A HREF="#cuesheet_track"><TT>CUESHEET_TRACK</TT></A>+</TD>
<TD>Один или больше треков. В блоке CUESHEET обязательно должен быть завершающий трек@@@@. По спецификации Red Book на аудиодисках номер завершающего трека должен равняться 170.</TD></TR>
</TABLE></P>

<P><TABLE WIDTH="100%" BORDER="1">

<TR>
<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="cuesheet_track"><FONT SIZE="+1"><B><TT>CUESHEET_TRACK</TT></B></FONT></A></TD>
</TR>


<TR>
<TD>&lt;64&gt;</TD>
<TD>Смещение трека в сэмплах относительно начала аудиопотока FLAC. Это смещение для первой индексной точки трека. (Обратите внимание на отличие от аудиодиска, где смещение трека в содержании хранится в INDEX 01, даже если есть INDEX 00.)  В аудиодиске смещение всегда кратно 588 (588 сэмплов = 44100 сэмплов/сек. * 1/75 сек.).</TD></TR>

<TR>
<TD>&lt;8&gt;</TD>
<TD>Номер трека. Номер трека 0 недопустим, чтобы избежать конфликта со спецификацией аудиодиска, которая резервирует этот номер для начального трека. Для аудиодиска номер должен быть от 1 до 99 или 170 для завершающего трека. Не является необходимым, но рекомендуется начинать нумерацию с 1 и увеличивать номера последовательно. Номера треков в списке должны быть уникальными.</TD></TR>

<TR>
<TD>&lt;12*8&gt;</TD>
<TD>Международный стандартный код записи (ISRC) для трека. Это 12-символьный код, состоящий только из цифр; см. <A HREF="http://www.ifpi.org/isrc/isrc_handbook.html">здесь</A> и <A HREF="http://www.discusa.com/cdref/cdaudio/isrc.htm">здесь</A>. Значение из 12 пустых символов ASCII можно использовать, чтобы указать на отсутствие ISRC.</TD></TR>

<TR>
<TD>&lt;1&gt;</TD>
<TD>Тип трека: 0 - для аудио, 1 - для остальных типов данных. Это поле соответствует третьему контольному биту Q-канала аудиодиска.</TD></TR>

<TR>
<TD>&lt;1&gt;</TD>
<TD>Флаг предварительной корелляции: 0 -- если ее нет, иначе 1. Соответствует 5 контрольному биту Q-канала аудиодиска; см. <A HREF="http://www.chipchapin.com/CDMedia/cdda9.php3">здесь</A>.</TD></TR>

<TR>
<TD>&lt;6+13*8&gt;</TD>
<TD>Зарезервировано. Все биты должны быть равны 0.</TD></TR>

<TR>
<TD>&lt;8&gt;</TD>
<TD>Число индексных точек трека. Для каждого трека должен быть хотя бы один индекс, кроме завершающего, у которого нет индекса. У аудиодиска это число не должно быть больше 100.</TD></TR>

<TR>
<TD><A HREF="#cuesheet_track_index"><TT>ИНДЕКС_ТРЕКА_В_СПИСКЕ</TT></A>+</TD>
<TD>Одна или больше индексных точек для трека.</TD></TR>
</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">
<TR>
<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="cuesheet_track_index"><FONT SIZE="+1"><B>ИНДЕКС_ТРЕКА_В_СПИСКЕ</B></FONT></A></TD></TR>

<TR>
<TD>&lt;64&gt;</TD>
<TD>Смещение в сэмплах индексной точки относительно смещения трека. Для аудиодиска смещение должно быть кратно 588 (588 сэмплов = 44100 сэмплов/сек. * 1/75 сек.).  Обратите внимание на то, что смещение берется от начала трека, а не от начала аудиоданных.</TD></TR>

<TR>
<TD>&lt;8&gt;</TD>
<TD>Номер индексной точки. Первый индекс трека должен иметь номер 0 или 1, а далее номера индексов должны последовательно увеличиваться на 1. Номера индексов для трека должны быть уникальны.</TD></TR>

<TR>
<TD>&lt;3*8&gt;</TD>
<TD>Зарезервировано. Все биты должны быть равны 0.</TD></TR>
</TABLE></P>

<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="frame"><FONT SIZE="+2"><B><TT>ФРЕЙМ</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#frame_header"><TT>ЗАГОЛОВОК_ФРЕЙМА</TT></A></TD>
	<TD>&nbsp;</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#subframe"><TT>ПОДФРЕЙМ</TT></A>+</TD>
	<TD>Один подфрейм на канал</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;?&gt;</TD>
	<TD>Выравнивание нулями на границу байта</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#frame_footer"><TT>ЗАВЕРШЕНИЕ_ФРЕЙМА</TT></A></TD>
	<TD>&nbsp;</TD>1</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="frame_header"><FONT SIZE="+2"><B><TT>ЗАГОЛОВОК_ФРЕЙМА</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;14&gt;</TD>
	<TD>код синхронизации <TT>11111111111110</TT></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;2&gt;</TD>
	<TD>Зарезервировано:
	<UL>
		<LI>00 : обязательное значение</LI>
		<LI>01-11 : зарезервировано для последующего использования</LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;4&gt;</TD>
	<TD>Размер блока в сэмплах:
	<UL>
		<LI>0000 : получить из блока метаданных <TT>STREAMINFO</TT></LI>
		<LI>0001 : <TT>192</TT> сэмпла</LI>
		<LI>0010-0101 : <TT>576 * (2^(2-n))</TT> сэмплов, т.е. <TT>576/1152/2304/4608</TT></LI>
		<LI>0110 : получить 8 битов (размер блока-1) из конца заголовка</LI>
		<LI>0111 : получить 16 битов (размер блока-1) из конца заголовка</LI>
		<LI>1000-1111 : <TT>256 * (2^(n-8))</TT> сэмплов, т.е. <TT>256/512/1024/2048/4096/8192/16384/32768</TT></LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;4&gt;</TD>
	<TD>Частота дискретизации:
	<UL>
		<LI><TT>0000</TT> : получить из блока метаданных <TT>STREAMINFO</TT></LI>
		<LI><TT>0001-0011</TT> : зарезервированы</LI>
		<LI><TT>0100</TT> : 8кГц</LI>
		<LI><TT>0101</TT> : 16кГц</LI>
		<LI><TT>0110</TT> : 22.05кГц</LI>
		<LI><TT>0111</TT> : 24кГц</LI>
		<LI><TT>1000</TT> : 32кГц</LI>
		<LI><TT>1001</TT> : 44.1кГц</LI>
		<LI><TT>1010</TT> : 48кГц</LI>
		<LI><TT>1011</TT> : 96кГц</LI>
		<LI><TT>1100</TT> : получить 8-битное значение частоты дискретизации (в кГц) из конца заголовка</LI>
		<LI><TT>1101</TT> : получить 16-битное значение частоты дискретизации (в Гц) из конца заголовка</LI>
		<LI><TT>1110</TT> : получить 16-битное значение частоты дискретизации (в дГц) из конца заголовка</LI>
		<LI><TT>1111</TT> : ошибочное значение, чтобы не допустить совпадение с кодом синхронизации</LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;4&gt;</TD>
	<TD>Расположение каналов:
	<UL>
		<LI><TT>0000-0111</TT> : <TT>(количество независимых каналов)-1</TT>. Когда == <TT>0001</TT>, канал <TT>0</TT> является левым, <TT>1</TT> - правым</LI>
		<LI><TT>1000</TT> : левостороннее стерео: канал <TT>0</TT> является левым, <TT>1</TT> - разностным</LI>
		<LI><TT>1001</TT> : правостороннее стерео: канал <TT>0</TT> является разностным, <TT>1</TT> - правым</LI>
		<LI><TT>1010</TT> : усредненное стерео: канал <TT>0</TT> является усредненным, <TT>1</TT> - разностным
		<LI><TT>1011-1111</TT> : зарезервированы</LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;3&gt;</TD>
	<TD>Количество битов на сэмпл:
	<UL>
		<LI><TT>000</TT> : получить из блока метаданных <TT>STREAMINFO</TT></LI>
		<LI><TT>001</TT> : 8 бит на сэмпл</LI>
		<LI><TT>010</TT> : 12 бит на сэмпл</LI>
		<LI><TT>011</TT> : зарезервировано</LI>
		<LI><TT>100</TT> : 16 бит на сэмпл</LI>
		<LI><TT>101</TT> : 20 бит на сэмпл</LI>
		<LI><TT>110</TT> : 24 бит на сэмпл</LI>
		<LI><TT>111</TT> : зарезервировано</LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;1&gt;</TD>
	<TD>Дополнение нулем до границы бита, чтобы не допустить ошибку синхронизации</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;?&gt;</TD>
	<TD>Если <TT>(переменный размер блока)</TT><BR>
		&nbsp;&nbsp;&nbsp;<8-56> : номер сэмпла в формате UTF-8 (размер декодируемого числа 36 бит)<BR>
		иначе<BR>
		&nbsp;&nbsp;&nbsp;<8-48> : номер фрейма в формате UTF-8 (размер декодируемого числа 31 бит)</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;?&gt;</TD>
	<TD>Если <TT>(битовая маска размера блока == 11x)</TT><BR>
		&nbsp;&nbsp;&nbsp;8/16 бит <TT>(размер блока - 1)</TT></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;?&gt;</TD>
	<TD>Если <TT>(битовая маска частоты дискретизации == 11xx)</TT><BR>
		&nbsp;&nbsp;&nbsp;частота дискретизации 8/16 бит</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;8&gt;</TD>
	<TD>8-битная полиномальная контрольная сумма <TT>(x^8 + x^2 + x^1 + x^0)</TT> данных заголовка, включая код синхронизации (<TT>x</TT> инициализируется нулем).</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&nbsp;</TD>
	<TD><B>Примечания</B>:
	<UL>
		<LI>Биты размера блока <TT>0000-0101</TT> могут быть использованы только при постоянном их значении во всем блоке. Биты <TT>0110-0111</TT> могут использоваться в любом случае, декодер будет считать, что поток имеет переменную длину блока. Существует одно исключение: кодер может использовать биты <TT>0110-0111</TT> в последнем фрейме потока с постоянным размером блока в том случае, если его длина не больше, чем используемая в всем потоке.</LI>
	</UL>
	</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="frame_footer"><FONT SIZE="+2"><B><TT>ЗАВЕРШЕНИЕ_ФРЕЙМА</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;16&gt;</TD>
	<TD>16-битная полиномальная контрольная сумма <TT>(x^16 + x^15 + x^2 + x^0)</TT> всего фрейма (<TT>x</TT> инициализируется нулем).</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="subframe"><FONT SIZE="+2"><B><TT>ПОДФРЕЙМ</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#subframe_header"><TT>ЗАГОЛОВОК_ПОДФРЕЙМА</TT></A></TD>
	<TD>&nbsp;</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#subframe_constant"><TT>ПОДФРЕЙМ_CONSTANT</TT></A> || <A HREF="format.html#subframe_fixed"><TT>ПОДФРЕЙМ_FIXED</TT></A> ||<BR><A HREF="format.html#subframe_lpc"><TT>ПОДФРЕЙМ_LPC</TT></A> || <A HREF="format.html#subframe_verbatim"><TT>ПОДФРЕЙМ_VERBATIM</TT></A></TD>
	<TD>Тип подфрейма, определяемый в заголовке</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="subframe_header"><FONT SIZE="+2"><B><TT>ЗАГОЛОВОК_ПОДФРЕЙМА</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;1&gt;</TD>
	<TD>Бит равный <TT>0</TT>, чтобы предотвратить ошибку синхронизации.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;6&gt;</TD>
	<TD>Тип подфрейма:
	<UL>
		<LI><TT>000000</TT> : <A HREF="format.html#subframe_constant"><TT>ПОДФРЕЙМ_CONSTANT</TT></A></LI>
		<LI><TT>000001</TT> : <A HREF="format.html#subframe_verbatim"><TT>ПОДФРЕЙМ_VERBATIM</TT></A></LI>
		<LI><TT>00001x</TT> : зарезервировано</LI>
		<LI><TT>0001xx</TT> : зарезервировано</LI>
		<LI><TT>001xxx</TT> : Если (<TT>xxx</TT> <= 4) <A HREF="format.html#subframe_fixed"><TT>ПОДФРЕЙМ_FIXED</TT></A>, <TT>xxx</TT> = порядок; иначе зарезервировано</LI>
		<LI><TT>01xxxx</TT> : зарезервировано</LI>
		<LI><TT>1xxxxx</TT> : <A HREF="format.html#subframe_lpc"><TT>ПОДФРЕЙМ_LPC</TT></A>, <TT>xxxxx = порядок-1</TT></LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;1+k&gt;</TD>
	<TD>Флаг 'неиспользуемые биты на сэмпл':
	<UL>
		<LI>0 : в исходном подблоке нет 'неиспользуемых битов', <TT>k=0</TT></LI>
		<LI>1 : <TT>k</TT> 'неиспользуемых битов' в исходном подблоке, число записывается в унарном формате; т.е. для <TT>k=3</TT> последовательность битов будет выглядеть так <TT>001</TT>, для <TT>k=7</TT> - <TT>0000001</TT>.</LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&nbsp;</TD>
	<TD><B>Примечания</B>:
	<UL>
		<LI>'Неиспользуемые биты' встречаются в блоке данных, если при заявленных <TT>n</TT> битах значимыми являются только <TT>m</TT>. Число <TT>k = n - m</TT> и будет определять количество 'неиспользуемых битов'. Например, если все 16-битные сэмплы в исходном подблоке выглядят как 'xxxxxxxxxxxxx000', то кодер кодирует только 13 бит, и запоминает, что 3 бита являются 'неиспользуемыми'.</LI>
	</UL>
	</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR><TD COLSPAN="2" BGCOLOR="#E0E0E0">
<A NAME="subframe_constant"><FONT SIZE="+2"><B><TT>
ПОДФРЕЙМ_CONSTANT</TT></B></FONT></A></TD></TR>

<TR><TD VALIGN="TOP">
&lt;n&gt;</TD>
<TD>Несжатое постоянное значение подблока, <TT>n</TT> равно количеству битов на сэмпл во фрейме</TD><TR>
</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="subframe_fixed"><FONT SIZE="+2"><B><TT>ПОДФРЕЙМ_FIXED</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;n&gt;</TD>
	<TD>Некодируемые начальные сэмплы (<TT>n</TT> равно количеству битов на сэмпл во фрейме, умноженному на порядок предиктора).</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#residual"><TT>ОСТАТОК</TT></A></TD>
	<TD>Закодированный остаток</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="subframe_lpc"><FONT SIZE="+2"><B><TT>ПОДФРЕЙМ_LPC</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;n&gt;</TD>
	<TD>Некодируемые начальные сэмплы (<TT>n</TT> равно количеству битов на сэмпл во фрейме, умноженному на порядок предиктора).</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;4&gt;</TD>
	<TD><TT>(точность дискретного коэффициета линейного прогнозирования (QLP)) - 1</TT>. Значение <TT>1111</TT> недопустимо.</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;5&gt;</TD>
	<TD>Необходимый сдвиг дискретного коэффициета линейного прогнозирования в битах. (<B>Примечание</B>: это число - знаковое дополнение до двух).</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;n&gt;</TD>
	<TD>Несжатые коэффициенты прогнозирования <TT>(n = точность QLP * порядок LPC)</TT> (<B>Примечание</B>: эти числа являются знаковыми дополнениями до двух).</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#residual"><TT>ОСТАТОК</TT></A></TD>
	<TD>Закодированный остаток</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="subframe_verbatim"><FONT SIZE="+2"><B><TT>ПОДФРЕЙМ_VERBATIM</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;n*i&gt;</TD>
	<TD>Несжатый подблок, <TT>n</TT> равно количеству битов на сэмпл во фрейме, <TT>i</TT> - размеру блока</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="residual"><FONT SIZE="+2"><B><TT>ОСТАТОК</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;2&gt;</TD>
	<TD>Метод кодирования остатков:
	<UL>
		<LI><TT>00</TT> : кодирование Райса</LI>
		<LI><TT>01-11</TT> : зарезервировано</LI>
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#partitioned_rice"><TT>ОСТАТКИ_СЖАТЫЕ_МЕТОДОМ_РАЙСА</TT></A></TD>
	<TD>&nbsp;</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&nbsp;</TD>
	<TD><B>Примечания:</B>
	<UL>
		<LI>Сейчас FLAC использует только один метод кодирования остатков</LI>
	</UL>
	</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="partitioned_rice"><FONT SIZE="+2"><B><TT>ОСТАТКИ_СЖАТЫЕ_МЕТОДОМ_РАЙСА</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;4&gt;</TD>
	<TD>Порядок раздела</TD>
</TR>

<TR>
	<TD VALIGN="TOP"><A HREF="format.html#rice_partition"><TT>РАЗДЕЛ_РАЙСА</TT></A>+</TD>
	<TD>Далее следуют 2^порядок разделов</TD>
</TR>

</TABLE></P>


<P><TABLE WIDTH="100%" BORDER="1">

<TR>
	<TD COLSPAN="2" BGCOLOR="#E0E0E0"><A NAME="rice_partition"><FONT SIZE="+2"><B><TT>РАЗДЕЛ_РАЙСА</TT></B></FONT></A></TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;4(+5)&gt;</TD>
	<TD>Параметр кодирования:
	<UL>
		<LI><TT>0000-1110</TT> : Параметр Райса.</LI>
		<LI><TT>1111</TT> : Код, означающий, что раздел является несжатым и в нем используются <TT>n</TT> битов на сэмпл. <TT>n</TT> представлено 5-битным числом.
	</UL>
	</TD>
</TR>

<TR>
	<TD VALIGN="TOP">&lt;?&gt;</TD>
	<TD>Закодированный остаток. Количество сэмплов <TT>n</TT> в разделе определяется следующим образом:
	<UL>
		<LI>Если порядок раздела равен <TT>0</TT>, <TT>n</TT> равно размеру блока для фрейма.</LI>
		<LI>иначе если это не первый раздел подфрейма, <TT>n = (размер блока для фрейма / (2^порядок раздела))</TT></LI>
		<LI>иначе <TT>n = (размер блока для фрейма / (2^порядок раздела)) - порядок предиктора</TT></LI>
	</UL>
	</TD>
</TR>

</TABLE></P>


<P>&nbsp;Copyright (c) 2000,2001,2002,2003,2004,2005,2006,2007  Josh Coalson</P>

</BODY>
</HTML>
